#include "hal_data.h"
#include "lv_port_disp.h"
#include "lv_apps\demo\demo.h"
#include "lv_tests\lv_test_theme\lv_test_theme_1.h"
#include "lv_tests\lv_test_theme\lv_test_theme_2.h"
#include "lv_tests\lv_test_theme\lv_test_theme_2.h"

bordecommdef boarduart;
Sys_str	Sys;  // 系统标志位等等参数
FG_DEF FG;


void r_flash_hp_bgo_example(void);
fsp_err_t r_flash_hp_bgo_2855 ( u8 const blocks,uint32_t const src_address,uint32_t const num_bytes);
void Turn_On_Animation(void);
void fFlashdata_read(void);
void fFlashdata_deal(void);
void fDeviceData_Init(void);


Motor_str Motorpara=  //实际转速  计算方式 转速为频率的4倍 外设的频率 	是 48000000 应该是频率降低了1024倍分频 所以需要的速度 就是（46875*4）/250  放大10倍
{
	{4, 4,}, //关机时候
	{300, 300,}, //SPD1
	{900, 900,},	 //SPD2
	{1200, 1200,},	//SPD3
	{1400, 1400,},	//SPD4
	{1750, 1750,}, //SPD5
	{4, 4,},  //初始化 output
	{4, 4,},  //初始化 outputtmp
};
u16 tAuto_Spd[4]=  //自动模式下的风速
{
	500,900,1200,1400,
};


u16 tAQI_table[4][2]= {{10,13},{10,36},{31,66},{50,66}};
bool               interrupt_called;
flash_event_t      flash_event;


volatile u8 g_b_flash_event_not_blank=0;
volatile u8 g_b_flash_event_blank=0;
volatile u8 g_b_flash_event_erase_complete=0;
volatile u8 g_b_flash_event_write_complete=0;


lvgldefdef Lvgl;

u8 gTime5msflg = 0;  // 5ms定时标志位
u8 gTime100msflg = 0; // 100ms 定时标志位
u8 gTime500msflg = 0; // 100ms 定时标志位

u8 gTime1sflg = 0;	// 1S定时标志位
u8 gFre1hzflashflg = 0;  //1HZ 频率闪烁
u8 gFre0_5hzflashflg = 1;  //0.5HZ
//---------------------按键相关-------------------------------------
u8 KeyStatus = 0;
u8 KeyValue = 0;
u8 keyTemp = 0;



uint16_t g_touch_button_countvalue[TOUCH_CFG_NUM_BUTTONS];
uint16_t g_touch_button_reference[TOUCH_CFG_NUM_BUTTONS];
uint64_t button_status;
volatile uint8_t      g_qe_touch_flag;


FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER


LV_FONT_DECLARE(my_font_icon_B);
//LV_FONT_DECLARE(my_font_icon_100);
LV_FONT_DECLARE(my_font_icon_L);
LV_FONT_DECLARE(my_font_icon_Filter); //滤网复位时候的两个图标
LV_IMG_DECLARE (bosch);
LV_IMG_DECLARE (sleep5);

LV_IMG_DECLARE (Line_color);
LV_IMG_DECLARE (fanspd0);
LV_IMG_DECLARE (fanspd1);
LV_IMG_DECLARE (fanspd2);
LV_IMG_DECLARE (fanspd3);
LV_IMG_DECLARE (fanspd4);
LV_IMG_DECLARE (fanspd5);
LV_IMG_DECLARE (obj_img_Bosch);

void LCD_WR_REG(u8 regval);
void LCD_WR_DATA(u8 data);





#define MANUAL 1
#define AUTO 0

#define wendu  "\xEE\x98\x88"
#define timer  "\xEE\x98\x81"
#define sheshidu  "\xEE\x98\x82"
#define shuidi  "\xEE\x98\x87"
#define baifenbi  "\xEE\x98\x84"
#define mode_manual "\xEE\x98\x83"
#define mode_auto "\xEE\x98\x80"
#define wifi "\xEE\x98\x85"
#define ChildLock "\xEE\x98\x86"

//#define fengsu "\xEE\x98\x8b\xEE\x98\x8c\xEE\x98\x8d\xEE\x98\x8e\xEE\x98\x8f"

#define FILTER_RSR1 "\xEE\x98\x8a"
#define FILTER_RSR  	"\xEE\x98\x89"

char  table_timer[6]= {0xee,0x98,0x81,0x39,0x39,'h'};
char  table_temp[9]= {0xee,0x98,0x88,'-',0xee,0x98,0x82,0x00};
char  table_humi[8]= {0xee,0x98,0x87,'-',0xee,0x98,0x84,0x00};
char  table_pm25[3]= {'0','0','0'};
char  table_tvoc[3]= {'L','0','0'};
char  table_filterpercent[15]= {'#','5','E','B','D','8','2',' ',0x31,0x30,0x30,0xee,0x98,0x84,'#'};
char  const table_100percent[4]= {0xee,0x98,0x84,'#'};
char  const table_100percentdispgreen[15]= {'#','5','E','B','D','8','2',' ',0x31,0x30,0x30,0xee,0x98,0x84,'#'}; //5EBD82 绿色


u8 tim1ms_flg = 0;
static u16 Animation_cnt = 0;
static u8 Animationsteps = 0;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
lv_obj_t* label1;
lv_obj_t* cont1;
lv_obj_t* cont2;

lv_obj_t* label_temperature;
lv_obj_t* label_humi;
lv_obj_t* label_childlock;
lv_obj_t* label_wifi;
lv_obj_t* scr;


lv_obj_t* label_timer;
lv_obj_t* label_auto_manual;
lv_obj_t* label_pm25;
lv_obj_t* label_pm25value;
lv_obj_t* label_tvoc;
lv_obj_t* label_tvocvalue;



lv_obj_t* line1;  //中间竖着的线条
lv_obj_t* line2;	//下方横着的线条
lv_obj_t* Img_ColorLine;//屏幕上方横着的彩色线条
lv_obj_t* Img_fanstate;//屏幕上方横着的彩色线条
lv_obj_t* obj_img_sleep;
lv_obj_t* obj_img_bosch;




lv_style_t label_style_auto_manual; //两个模式样式是一样的
lv_style_t Img_style_ColorLine;
lv_style_t src1_style_3rd;
lv_style_t src1_style_Mainscreen;
lv_style_t src1_style_Mainscreen_Bigstyle; //大字体
lv_style_t src1_style_Mainscreen_Littlestyle; //大字体
lv_style_t src1_style_Mainscreen_Timer;
lv_style_t src1_style_Mainscreen_Wifi;
lv_style_t src1_style_Mainscreen_Lock;



lv_style_t src1_style_2nd;
lv_style_t img_style_sleep;







const lv_point_t line_points[] = { {159, 65}, {159, 180}};
//  坐标点的个数
#define LINE_POINTS_NUM (sizeof(line_points)/sizeof(line_points[0]))

const lv_point_t line_points1[] = { {10, 190}, {310, 190}};
//  坐标点的个数
#define LINE_POINTS_NUM1 (sizeof(line_points1)/sizeof(line_points1[0]))
//	void Mainscreen_create(void)  // 创建主屏幕
//	{
//
//		label_auto_manual = lv_label_create(scr,NULL); //创建一个标签
//		lv_label_set_long_mode(label_auto_manual,LV_LABEL_LONG_CROP);
//		lv_obj_set_size(label_auto_manual,40,40);
//		lv_label_set_style(label_auto_manual,LV_LABEL_STYLE_MAIN,&src1_style_Mainscreen);
//		lv_obj_align(label_auto_manual,scr,LV_ALIGN_IN_TOP_LEFT,0,10);
//		lv_label_set_align(label_auto_manual,LV_ALIGN_IN_TOP_LEFT);
//		if(1 == AUTO)
//			lv_label_set_text(label_auto_manual,mode_auto);
//		else
//			lv_label_set_text(label_auto_manual,mode_manual);
//		//画彩图
//		Img_ColorLine=lv_img_create (scr, NULL);
//		lv_img_set_style(Img_ColorLine, LV_IMG_STYLE_MAIN, &src1_style_2nd);
//		lv_img_set_src (Img_ColorLine, &Line_color);
//		lv_obj_set_pos (Img_ColorLine,10,50);

//		line1 = lv_line_create (scr, NULL);
//		lv_line_set_points (line1, line_points,LINE_POINTS_NUM);
//		lv_line_set_style (line1, LV_LINE_STYLE_MAIN, &src1_style_Mainscreen);
//		line2 = lv_line_create (scr, line1);
//		lv_line_set_points (line2, line_points1,LINE_POINTS_NUM1);
//
//
//
//
//		//	//定时标签
//		label_timer = lv_label_create(scr,label_auto_manual); //创建一个标签
//		lv_obj_set_size(label_timer,120,40);
//		lv_obj_align(label_timer,scr,LV_ALIGN_IN_TOP_MID,-30,10);
//		lv_label_set_align(label_timer,LV_ALIGN_IN_TOP_MID);
//		lv_label_set_array_text(label_timer,(const char*)&table_timer,5);

//		// 温度标签
//		label_temperature = lv_label_create(scr,label_auto_manual); //创建一个标签
//		lv_obj_set_size(label_temperature,120,40);
//		lv_obj_align(label_temperature,scr,LV_ALIGN_IN_BOTTOM_LEFT,30,0);
//		lv_label_set_align(label_temperature,LV_ALIGN_IN_BOTTOM_LEFT);
//		lv_label_set_array_text(label_temperature,(const char*)&table_temp,8);

//		//湿度标签
//		label_humi = lv_label_create(scr,label_auto_manual); //创建一个标签
//		lv_obj_set_size(label_humi,120,40);
//		lv_obj_align(label_humi,scr,LV_ALIGN_IN_BOTTOM_MID,80,0);
//		lv_label_set_align(label_humi,LV_ALIGN_IN_BOTTOM_MID);
//		lv_label_set_array_text(label_humi,(const char*)&table_humi,8);
//		//wifi和童锁
//		label_childlock = lv_label_create(scr,label_auto_manual); //创建一个标签
//		lv_obj_align(label_childlock,scr,LV_ALIGN_IN_TOP_MID,80,10);
//		lv_label_set_align(label_childlock,LV_ALIGN_IN_TOP_MID);
//		lv_label_set_text(label_childlock,childlock);

//		label_wifi = lv_label_create(scr,label_auto_manual); //创建一个标签
//		lv_obj_align(label_wifi,scr,LV_ALIGN_IN_TOP_MID,120,10);
//		lv_label_set_align(label_wifi,LV_ALIGN_IN_TOP_MID);
//		lv_label_set_text(label_wifi,wifi);


//		//风速指示
//		Img_fanstate=lv_img_create (scr, Img_ColorLine);
//		lv_img_set_style (Img_fanstate, LV_IMG_STYLE_MAIN,&src1_style_2nd);
//		lv_obj_set_size (Img_fanstate, 40, 40);
//		lv_img_set_src (Img_fanstate, &fanspd2);
//		lv_obj_set_pos (Img_fanstate,40,10);

//		label_pm25 =lv_label_create(scr,label_auto_manual); //创建一个标签
//		lv_label_set_long_mode(label_pm25,LV_LABEL_LONG_EXPAND);
//		lv_obj_set_pos (label_pm25, 40, 80);
//		lv_label_set_text(label_pm25,"PM2.5");
//		label_tvoc =lv_label_create(scr,label_pm25);
//		lv_obj_set_pos (label_tvoc, 207, 80);
//		lv_label_set_text(label_tvoc,"TVOC");
//

//		label_pm25value = lv_label_create(scr,label_auto_manual); //创建一个标签
//		src1_style_2nd.text.letter_space = -2;
//		lv_label_set_long_mode(label_pm25value,LV_LABEL_LONG_EXPAND);
//		lv_obj_set_size(label_pm25value,100,50);
//		lv_label_set_style(label_pm25value,LV_LABEL_STYLE_MAIN,&src1_style_2nd);
//		lv_obj_set_pos (label_pm25value, 37, 120);
//		lv_label_set_text(label_pm25value,"100");
//		label_tvocvalue = lv_label_create(scr,label_pm25value);
//		lv_obj_set_pos (label_tvocvalue, 190, 120);
//		lv_label_set_text(label_tvocvalue,"0.15");
//
//		src1_style_Mainscreen.image.opa = 255;
//		src1_style_Mainscreen.text.opa = 255;
//		src1_style_2nd.line.opa = 255;
//		src1_style_2nd.image.opa = 255;

//	}





void delay_cnt(u32 cnt)
{
	cnt = cnt*11800;
	while(cnt)
		cnt--;

}

void delay(u8 cnt)
{
	while(cnt)
		cnt--;
}





void Task_Tvocvalurefresh(u16 tvocvalue)
{
	if(tvocvalue<10)
	{
		table_tvoc[1] = 0x30+tvocvalue;
		lv_label_set_array_text(label_tvocvalue,(const char*)&table_tvoc[0],2);
	}
	else
	{
		table_tvoc[1] = 0x30+tvocvalue/10;
		table_tvoc[1] = 0x30+tvocvalue%10;
		lv_label_set_array_text(label_tvocvalue,(const char*)&table_tvoc[0],3);
	}

}


void Task_Pm25valuerefresh(u16 pm25value)
{

	if(pm25value<10)
	{
		table_pm25[0] = 0x30+pm25value;
		lv_label_set_array_text(label_pm25value,(const char*)&table_pm25[0],1);

	}
	else if(pm25value<100)
	{
		table_pm25[0] = 0x30+pm25value/10;
		table_pm25[1] = 0x30+pm25value%10;
		lv_label_set_array_text(label_pm25value,(const char*)&table_pm25[0],2);

	}
	else
	{
		table_pm25[0] = 0x30+pm25value/100;
		table_pm25[1] = 0x30+pm25value%100/10;
		table_pm25[2] = 0x30+pm25value%10;
		lv_label_set_array_text(label_pm25value,(const char*)&table_pm25[0],3);
	}
	pm25value = 14;
	table_pm25[0] = 0x30+pm25value/100;
	table_pm25[1] = 0x30+pm25value%100/10;
	table_pm25[2] = 0x30+pm25value%10;
	lv_label_set_array_text(label_pm25value,(const char*)&table_pm25[0],3);
}



void Task_Moderefresh(emode opmode)
{
	if(opmode == emodeAuto)
		lv_label_set_text(label_auto_manual,mode_auto);
	else
		lv_label_set_text(label_auto_manual,mode_manual);

}



void Task_Fanrefresh(espd fanspd)
{

	switch (fanspd)
	{
	case espd1:
		lv_img_set_src (Img_fanstate, &fanspd1);
		break;
	case espd2:
		lv_img_set_src (Img_fanstate, &fanspd2);
		break;
	case espd3:
		lv_img_set_src (Img_fanstate, &fanspd3);
		break;
	case espd4:
		lv_img_set_src (Img_fanstate, &fanspd4);
		break;
	case espd5:
		lv_img_set_src (Img_fanstate, &fanspd5);
		break;
	default:
		lv_img_set_src (Img_fanstate, &fanspd0);
		break;
	}
	if(lv_obj_get_hidden(Img_fanstate)==true)
	{
		lv_obj_set_hidden(Img_fanstate, false);
	}
	// if(Sys.opmode == emodeAuto)
	// {

	// 	if(lv_obj_get_hidden(Img_fanstate)==false)
	// 	{
	// 		lv_obj_set_hidden(Img_fanstate, true);
	// 	}
	// }
	// else
	// {
	// 	if(lv_obj_get_hidden(Img_fanstate)==true)
	// 	{
	// 		lv_obj_set_hidden(Img_fanstate, false);
	// 	}
	// }
}

void Task_Humirefresh(u8 Humi)
{
	if(Humi>99)
		Humi = 99;
	if(Humi>=10)
	{
		table_humi[3] = Humi/10+0x30;
		table_humi[4] = Humi%10+0x30;
		table_humi[5] = 0xee;
		table_humi[6] = 0x98;
		table_humi[7] = 0x84;
		lv_label_set_array_text(label_humi,(const char*)&table_humi[0],8);
	}
	else
	{
		table_humi[3] = Humi%10+0x30;
		table_humi[4] = 0xee;
		table_humi[5] = 0x98;
		table_humi[6] = 0x84;
		lv_label_set_array_text(label_humi,(const char*)&table_humi[0],7);
	}


}




void Task_Temprefresh(signed char temp)
{
	if(temp>99)
		temp = 99;
	if(temp>10)
	{
		table_temp[3] = temp/10+0x30;
		table_temp[4] = temp%10+0x30;
		table_temp[5] = 0xee;
		table_temp[6] = 0x98;
		table_temp[7] = 0x82;
		lv_label_set_array_text(label_temperature,(const char*)&table_temp[0],8);
	}
	else if(temp>=0)
	{
		table_temp[3] = temp%10+0x30;
		table_temp[4] = 0xee;
		table_temp[5] = 0x98;
		table_temp[6] = 0x82;
		lv_label_set_array_text(label_temperature,(const char*)&table_temp[0],7);
	}
	else if(temp>(-10))
	{
		temp= abs(temp);
		table_temp[3] = '-';
		table_temp[4] = temp%10+0x30;
		table_temp[5] = 0xee;
		table_temp[6] = 0x98;
		table_temp[7] = 0x82;
		lv_label_set_array_text(label_temperature,(const char*)&table_temp[0],8);
	}
	else
	{
		temp= abs(temp);
		table_temp[3] = '-';
		table_temp[4] = temp/10+0x30;
		table_temp[5] = temp%10+0x30;
		table_temp[6] = 0xee;
		table_temp[7] = 0x98;
		table_temp[8] = 0x82;
		lv_label_set_array_text(label_temperature,(const char*)&table_temp[0],9);
	}

}

void Task_Line_Imagecreate(void)
{
	if(line1==NULL)
	{
		line1 = lv_line_create (scr, NULL);
		lv_line_set_points (line1, line_points,LINE_POINTS_NUM);
		lv_line_set_style (line1, LV_LINE_STYLE_MAIN, &src1_style_Mainscreen_Bigstyle);
		line2 = lv_line_create (scr, line1);
		lv_line_set_points (line2, line_points1,LINE_POINTS_NUM1);
		src1_style_Mainscreen_Bigstyle.line.opa = 0;
		src1_style_Mainscreen_Bigstyle.line.color  = LV_COLOR_MAKE(0x52,0x5f,0x6b); //色号是#525F6B

	}
	//画彩图
	if(Img_ColorLine==NULL)
	{
		Img_ColorLine=lv_img_create (scr, NULL);
		lv_img_set_style(Img_ColorLine, LV_IMG_STYLE_MAIN, &src1_style_Mainscreen_Bigstyle);
		lv_img_set_src (Img_ColorLine, &Line_color);
		lv_obj_set_pos (Img_ColorLine,10,50);
		src1_style_Mainscreen_Bigstyle.image.opa = 0;
	}
}


void Task_Sensordatacreate(void)
{
	if(label_pm25==NULL)
	{
		label_pm25 =lv_label_create(scr,NULL); //创建一个标签
		lv_label_set_long_mode(label_pm25,LV_LABEL_LONG_EXPAND);
		lv_obj_set_size(label_pm25,100,30);
		lv_label_set_style(label_pm25,LV_LABEL_STYLE_MAIN,&src1_style_Mainscreen_Littlestyle);
		lv_obj_set_pos (label_pm25, 35, 70);
		lv_label_set_text(label_pm25,"PM2.5");
		if(label_tvoc == NULL)
			label_tvoc =lv_label_create(scr,label_pm25);
		lv_obj_set_pos (label_tvoc, 195, 70);
		lv_label_set_text(label_tvoc,"TVOC");
		src1_style_Mainscreen_Littlestyle.text.opa = 0;


		if(label_pm25value == NULL)
			label_pm25value = lv_label_create(scr,NULL); //创建一个标签
		src1_style_Mainscreen_Bigstyle.text.letter_space = -2;
		lv_label_set_long_mode(label_pm25value,LV_LABEL_LONG_EXPAND);
		lv_label_set_align (label_pm25value, LV_LABEL_ALIGN_CENTER);
		//	lv_obj_set_size(label_pm25value,100,50);
		lv_label_set_style(label_pm25value,LV_LABEL_STYLE_MAIN,&src1_style_Mainscreen_Bigstyle);
		//	lv_obj_set_pos (label_pm25value, 37, 120);
		if(label_tvocvalue == NULL)
			label_tvocvalue = lv_label_create(scr,label_pm25value);
		//	lv_obj_set_pos (label_tvocvalue, 190, 120);
		lv_label_set_array_text(label_pm25value,(const char*)&table_pm25[0],3);
		lv_label_set_array_text(label_tvocvalue,(const char*)&table_tvoc[0],3);

		lv_obj_align(label_tvocvalue, scr, LV_ALIGN_CENTER, 80, 28);
		lv_obj_align(label_pm25value, scr, LV_ALIGN_CENTER, -78, 28);
		lv_obj_set_auto_realign (label_pm25value, true);
		lv_obj_set_auto_realign (label_tvocvalue, true);
		if(Sys.Warnup_Cnt<=300)  // 30S预热时间内显示
		{
			lv_label_set_array_text(label_tvocvalue,"---",3);
			lv_label_set_array_text(label_pm25value,"---",3);
		}
		else
		{
			Task_Tvocvalurefresh (Sys.tvocvalue);
			Task_Pm25valuerefresh(Sys.pm25value);
		}
		src1_style_Mainscreen_Bigstyle.text.opa = 0;
	}
}



void Task_Modecreate(void)
{
	//模式标签 auto 和 manual
	if(label_auto_manual == NULL)
	{
		label_auto_manual = lv_label_create(scr,NULL); //创建一个标签
		lv_label_set_long_mode(label_auto_manual,LV_LABEL_LONG_CROP);
		lv_obj_set_size(label_auto_manual,40,40);
		lv_label_set_style(label_auto_manual,LV_LABEL_STYLE_MAIN,&src1_style_Mainscreen);
//		lv_obj_align(label_auto_manual,scr,LV_ALIGN_IN_TOP_LEFT,0,10);
//		lv_label_set_align(label_auto_manual,LV_ALIGN_IN_TOP_LEFT);
		lv_obj_set_pos (label_auto_manual,15,12);
		Task_Moderefresh(Sys.opmode);
		src1_style_Mainscreen.text.opa = 0;
	}

}


void Task_Fancreate(void)
{
	//风速指示
	if(Img_fanstate==NULL)
	{
		Img_fanstate=lv_img_create (scr, NULL);
		lv_img_set_style (Img_fanstate, LV_IMG_STYLE_MAIN,&src1_style_Mainscreen);
		lv_obj_set_size (Img_fanstate, 40, 40);
		Task_Fanrefresh (Sys.Speed.gearreal);
		lv_obj_set_pos (Img_fanstate,53,10);
		// if(Sys.opmode == emodeAuto)
		// {
		// 	if(lv_obj_get_hidden(Img_fanstate)==false)
		// 	{
		// 		lv_obj_set_hidden(Img_fanstate, true);
		// 	}
		// }
		// else
		// {
		// 	if(lv_obj_get_hidden(Img_fanstate)==true)
		// 	{
		// 		lv_obj_set_hidden(Img_fanstate, false);
		// 	}
		// }
	}
}

void Task_Wificreate(void)
{
	if(label_wifi==NULL)
	{
		label_wifi = lv_label_create(scr,NULL); //创建一个标签
		lv_img_set_style(label_wifi, LV_IMG_STYLE_MAIN, &src1_style_Mainscreen_Wifi);
		lv_obj_align(label_wifi,scr,LV_ALIGN_IN_TOP_MID,140,9);
		lv_label_set_align(label_wifi,LV_ALIGN_IN_TOP_MID);
		lv_label_set_text(label_wifi,wifi);
		src1_style_Mainscreen_Wifi.text.opa =0;
	}
}

void Task_Childlockcreate(void)
{
	if(label_childlock==NULL)
	{
		label_childlock = lv_label_create(scr,NULL); //创建一个标签
		lv_img_set_style(label_childlock, LV_IMG_STYLE_MAIN, &src1_style_Mainscreen_Lock);
		lv_obj_align(label_childlock,scr,LV_ALIGN_IN_TOP_MID,100,12);
		lv_label_set_align(label_childlock,LV_ALIGN_IN_TOP_MID);

		lv_label_set_text(label_childlock,ChildLock);
		src1_style_Mainscreen_Lock.text.opa = 0;
	}
}

void Task_Timercreate(void)
{
	if(label_timer==NULL)
	{
		label_timer = lv_label_create(scr,label_auto_manual); //创建一个标签
		lv_label_set_long_mode (label_timer, LV_LABEL_LONG_EXPAND); //文字自动填充
		lv_obj_set_pos(label_timer,135,10);
		lv_label_set_style(label_timer, LV_LABEL_STYLE_MAIN, &src1_style_Mainscreen_Timer);
		lv_label_set_align (label_timer, LV_LABEL_ALIGN_CENTER);

		lv_label_set_array_text(label_timer,(const char*)&table_timer,5);
		lv_obj_align(label_timer, scr, LV_ALIGN_IN_TOP_MID, -1, 10);
		src1_style_Mainscreen_Timer.text.opa = 0;
		src1_style_Mainscreen_Timer.text.letter_space = 1;
		lv_obj_set_auto_realign (label_timer, true);
		src1_style_Mainscreen_Timer.text.opa = 0;
	}
}

void Task_Temperaturecreate(void) //温度标签的创建
{
	if(label_temperature==NULL)
	{
		label_temperature = lv_label_create(scr,label_auto_manual); //创建一个标签
		lv_label_set_long_mode (label_temperature, LV_LABEL_LONG_EXPAND);
		lv_obj_align(label_temperature,scr,LV_ALIGN_IN_BOTTOM_LEFT,33,-10);
		lv_label_set_align(label_temperature,LV_ALIGN_IN_BOTTOM_LEFT);
		lv_label_set_array_text(label_temperature,(const char*)&table_temp,8);
//		Task_Temprefresh(Sys.Tempvalue);
	}

}

void Task_Humicreate(void) //湿度标签的创建
{
	if(label_humi==NULL)
	{
		label_humi = lv_label_create(scr,label_auto_manual); //创建一个标签
		lv_label_set_long_mode (label_humi, LV_LABEL_LONG_EXPAND);
		lv_obj_align(label_humi,scr,LV_ALIGN_IN_BOTTOM_MID,49,-10);
		lv_label_set_align(label_humi,LV_ALIGN_IN_BOTTOM_MID);
		lv_label_set_array_text(label_humi,(const char*)&table_humi,8);
//		Task_Humirefresh(Sys.Humivalue);
	}
}


void Main_screen_display()
{
	src1_style_Mainscreen_Bigstyle.text.opa = 240;
	src1_style_Mainscreen_Bigstyle.image.opa = 200;
	src1_style_Mainscreen_Bigstyle.line.opa = 100;

	src1_style_Mainscreen.text.opa = 240;
	src1_style_Mainscreen.image.opa = 245;
	src1_style_Mainscreen.line.opa = 255;

	src1_style_Mainscreen_Littlestyle.text.opa = 240;
	src1_style_Mainscreen_Littlestyle.image.opa = 255;
	src1_style_Mainscreen_Littlestyle.line.opa = 255;
}

void Main_screen_clean()
{
	src1_style_Mainscreen_Bigstyle.text.opa = 0;
	src1_style_Mainscreen_Bigstyle.image.opa = 0;
	src1_style_Mainscreen_Bigstyle.line.opa = 0;

	src1_style_Mainscreen.text.opa = 0;
	src1_style_Mainscreen.image.opa = 0;
	src1_style_Mainscreen.line.opa = 0;

	src1_style_Mainscreen_Littlestyle.text.opa = 0;
	src1_style_Mainscreen_Littlestyle.image.opa = 0;
	src1_style_Mainscreen_Littlestyle.line.opa = 0;

	src1_style_Mainscreen_Lock.text.opa = 0;
	src1_style_Mainscreen_Wifi.text.opa = 0;
	src1_style_Mainscreen_Timer.text.opa = 0;
}




void Filter_display(void)  //滤网寿命显示
{
	static lv_obj_t* bar1;
	static lv_obj_t* obj_label_pic_filter;//滤网百分比的图标
	static lv_obj_t* obj_label_text_filterstatus;
	static lv_obj_t* obj_label_text_100percent;
	static lv_style_t Label_style_pic_filter;
	static lv_style_t Label_style_text_filterstatus;
	static lv_style_t cont1_style_main;
	static lv_style_t bar1_style_bg;
	static lv_style_t bar1_style_indic;
	if(Lvgl.Taskcomplete)
	{
		lv_obj_refresh_style (scr);
	}
	if(Lvgl.Filtercnt == 0)
	{
		lv_style_copy(&bar1_style_bg,&lv_style_plain_color);
		lv_style_copy(&bar1_style_indic,&lv_style_plain_color);
		lv_style_copy(&Label_style_text_filterstatus,&lv_style_plain_color);
		lv_style_copy(&cont1_style_main,&lv_style_plain_color);
		lv_style_copy(&Label_style_pic_filter,&lv_style_plain_color);
		if(cont2==NULL)
		{
			cont2= lv_cont_create(scr,NULL); //创建一个容器 父对象为屏幕
			obj_label_pic_filter = lv_label_create(cont2,NULL); //标签 滤网的图标
			bar1=lv_bar_create(obj_label_pic_filter,NULL);
			obj_label_text_filterstatus = lv_label_create(cont2,NULL); //创建filterstatus 字符标签
			obj_label_text_100percent = lv_label_create(cont2,NULL); //创建一个标签
		}
		else
			lv_obj_set_hidden (cont2, false);
		lv_obj_move_foreground (cont2);
		cont1_style_main.body.border.part=LV_BORDER_FULL;
		cont1_style_main.body.border.color =LV_COLOR_WHITE;
		lv_obj_set_size(cont2,226,180);
		lv_obj_set_pos(cont2,47,30);
		cont1_style_main.body.border.width = 1;
		lv_cont_set_style(cont2,LV_CONT_STYLE_MAIN,&cont1_style_main);
		lv_cont_set_fit(cont2,LV_FIT_NONE);
		lv_cont_set_layout(cont2,LV_LAYOUT_OFF);
		cont1_style_main.body.main_color = LV_COLOR_BLACK;
		cont1_style_main.body.grad_color = LV_COLOR_BLACK;
		cont1_style_main.body.border.opa = 60;  //



//----------------------滤网图标显示 需要显示不同符号 80大小----------------------------------//
		lv_label_set_recolor (obj_label_pic_filter,true);
		lv_label_set_style(obj_label_pic_filter,LV_LABEL_STYLE_MAIN,&Label_style_pic_filter);
		lv_obj_align(obj_label_pic_filter,cont2,LV_ALIGN_IN_LEFT_MID,30,-5);
		lv_label_set_align(obj_label_pic_filter,LV_ALIGN_CENTER);
		Label_style_pic_filter.text.font = &my_font_icon_Filter;
		lv_label_set_text (obj_label_pic_filter,FILTER_RSR1);
		Label_style_pic_filter.text.color = LV_COLOR_WHITE;
		Label_style_pic_filter.text.opa = 245;
		if(Sys.Filter.percentage==0)
			Label_style_pic_filter.text.color = LV_COLOR_MAKE(0xff,0x21,0x24);  //红色#FF2124;


//----------------------滤网图标内部百分比的图形Indicate显示----------------------------------//
		lv_obj_set_size(bar1,14,60);
		lv_bar_set_range(bar1,0,100);
		lv_bar_set_value(bar1,Sys.Filter.percentage,LV_ANIM_OFF);
		lv_bar_set_style(bar1,LV_BAR_STYLE_BG,&bar1_style_bg);
		lv_bar_set_style(bar1,LV_BAR_STYLE_INDIC,&bar1_style_indic);

		bar1_style_bg.body.main_color = LV_COLOR_BLACK;
		bar1_style_bg.body.grad_color = LV_COLOR_BLACK;
		if(Sys.Filter.percentage>50)
		{
			bar1_style_indic.body.main_color = LV_COLOR_MAKE(0x5e,0xbd,0x82); //绿色#5EBD82
			bar1_style_indic.body.grad_color = LV_COLOR_MAKE(0x5e,0xbd,0x82); //绿色#5EBD82
		}
		else if(Sys.Filter.percentage>20)
		{
			bar1_style_indic.body.main_color = LV_COLOR_MAKE(0xff,0xCF,0x00); //黄色#FFCF00
			bar1_style_indic.body.grad_color = LV_COLOR_MAKE(0xff,0xCF,0x00); //黄色#FFCF00
		}
		else
		{
			bar1_style_indic.body.main_color = LV_COLOR_MAKE(0xff,0x21,0x24);  //红色#FF2124
			bar1_style_indic.body.grad_color = LV_COLOR_MAKE(0xff,0x21,0x24);  //红色#FF2124
		}
		bar1_style_indic.body.radius = 0;
		bar1_style_indic.body.padding.inner =0;
		bar1_style_indic.body.padding.left = 0;
		bar1_style_indic.body.padding.top = 0;
		bar1_style_indic.body.padding.right = 0;
		bar1_style_indic.body.padding.bottom = 0;
		bar1_style_indic.body.border.part = LV_BORDER_FULL;
		lv_obj_align(bar1,obj_label_pic_filter,LV_ALIGN_CENTER,0,0); // -1 10
		bar1_style_bg.body.opa =245;
		bar1_style_indic.body.opa = 245;

//----------------------滤网Filter Status字符显示----------------------------------//
		Label_style_text_filterstatus.text.font = &my_font_icon_L;
		lv_label_set_long_mode (obj_label_text_filterstatus, LV_LABEL_LONG_EXPAND);
		lv_label_set_style(obj_label_text_filterstatus,LV_LABEL_STYLE_MAIN,&Label_style_text_filterstatus);
		lv_obj_set_size(obj_label_text_filterstatus,200,40);
		// lv_obj_align(obj_label_text_filterstatus,cont2,LV_ALIGN_IN_TOP_LEFT,25,15);
		lv_obj_align(obj_label_text_filterstatus,cont2,LV_ALIGN_IN_TOP_LEFT,25,15);
		lv_label_set_align(obj_label_text_filterstatus,LV_ALIGN_IN_TOP_MID);
		lv_obj_set_auto_realign (obj_label_text_filterstatus, true);
		lv_label_set_text (obj_label_text_filterstatus,"Filter status");
		// Label_style_text_filterstatus.text.letter_space = 0;
		Label_style_text_filterstatus.text.opa = 245;


//----------------------滤网100%字符显示 需要不同颜色显示----------------------------------//
		lv_label_set_recolor (obj_label_text_100percent,true);
		lv_obj_set_size(obj_label_text_100percent,160,40);
		lv_obj_align(obj_label_text_100percent,cont2,LV_ALIGN_CENTER,60,25);
		lv_obj_set_auto_realign(obj_label_text_100percent,true);
		lv_label_set_style(obj_label_text_100percent,LV_LABEL_STYLE_MAIN,&cont1_style_main);
		cont1_style_main.text.font = &my_font_icon_L;
//		lv_label_set_text (obj_label_text_100percent,"#0000FF 100%#");
		
		if(Sys.Filter.percentage>50) //绿色
		{
			memcpy(&table_filterpercent[0],"#5EBD82 ",8);
		}
		else if(Sys.Filter.percentage>20) //黄色
		{
			memcpy(&table_filterpercent[0],"#FFCF00 ",8);  //黄色#FFCF00
		}
		else
		{
			memcpy(&table_filterpercent[0],"#FF2124 ",8); //红色#FF2124
		}
		if(Sys.Filter.percentage==100)
		{
			table_filterpercent[8] = 0x30+1;
			table_filterpercent[9] = 0x30+Sys.Filter.percentage%100/10;
			table_filterpercent[10] = 0x30+Sys.Filter.percentage%10;
			memcpy(&table_filterpercent[11],table_100percent,4); //
			lv_label_set_array_text (obj_label_text_100percent, &table_filterpercent[0],15);
		}
		else if(Sys.Filter.percentage>=10) //修复10%不显示的bug
		{
			table_filterpercent[8] = 0x30+Sys.Filter.percentage/10;
			table_filterpercent[9] = 0x30+Sys.Filter.percentage%10;
			memcpy(&table_filterpercent[10],table_100percent,4); //
			lv_label_set_array_text (obj_label_text_100percent, &table_filterpercent[0],14);
		}
		else
		{
			table_filterpercent[8] = 0x30+Sys.Filter.percentage%10;
			memcpy(&table_filterpercent[9],table_100percent,4); //
			lv_label_set_array_text (obj_label_text_100percent, &table_filterpercent[0],13);
		}

		cont1_style_main.text.letter_space = 1;
		cont1_style_main.text.opa = 245;


	}
	
	if(++Lvgl.Filtercnt>=3000)
	{
		Lvgl.Filtercnt = 0;
		Lvgl.Curpfunction =Lvgl.Lastpfunction;
		// x1=lv_obj_get_x(obj_label_pic_filter);
		// y1=lv_obj_get_y(obj_label_pic_filter);
		// x2=lv_obj_get_x(obj_label_text_100percent);
		// y2=lv_obj_get_y(obj_label_text_100percent);

	}

}


void Filter_reset_animation(void)
{
	static lv_obj_t* bar1;
	static lv_obj_t* obj_label_pic_OK;//滤网百分比的图标
	static lv_obj_t* obj_label_pic_filter;//滤网百分比的图标
	static lv_obj_t* obj_label_text_filterreset;
	static lv_obj_t* obj_label_text_filterstatus;
	static lv_obj_t* obj_label_text_100percent;
	static lv_style_t Label_style_pic_OK;
	static lv_style_t Label_style_pic_filter;
	static lv_style_t Label_style_text_filterreset;
	static lv_style_t Label_style_text_filterstatus;
	static lv_style_t cont1_style_main;
	static lv_style_t bar1_style_bg;
	static lv_style_t bar1_style_indic;
	static  short offsetx  = 75;
	static  short offsety  = 76;
	if(Lvgl.Filtercnt == 400)
	{
		offsetx  = 75;
		offsety  = 76;
		lv_style_copy(&bar1_style_bg,&lv_style_plain_color);
		lv_style_copy(&bar1_style_indic,&lv_style_plain_color);
		lv_style_copy(&Label_style_pic_OK,&lv_style_plain_color);
		lv_style_copy(&Label_style_pic_filter,&lv_style_plain_color);
		lv_style_copy(&Label_style_text_filterreset,&lv_style_plain_color);
		lv_style_copy(&Label_style_text_filterstatus,&lv_style_plain_color);
		lv_style_copy(&cont1_style_main,&lv_style_plain_color);

		if(cont1==NULL)  //防止重复创建
		{
			cont1= lv_cont_create(scr,NULL); //创建一个容器 父对象为屏幕
			obj_label_pic_OK = lv_label_create(cont1,NULL); //创建一个标签 滤网复位绿色圆圈
			obj_label_pic_filter = lv_label_create(cont1,NULL); //标签 滤网的图标
			obj_label_text_filterreset = lv_label_create(cont1,NULL); //创建一个字符标签
			obj_label_text_filterstatus = lv_label_create(cont1,NULL); //创建filterstatus
			obj_label_text_100percent = lv_label_create(cont1,NULL); //创建一个标签
			bar1=lv_bar_create(obj_label_pic_filter,NULL);
		}
		else
			lv_obj_set_hidden (cont1, false);
		lv_obj_move_foreground (cont1);
		cont1_style_main.body.border.part=LV_BORDER_FULL;
		cont1_style_main.body.border.color =LV_COLOR_WHITE;
		lv_obj_set_size(cont1,226,180);
		lv_obj_set_pos(cont1,47,30);
		cont1_style_main.body.border.width = 1;
		lv_cont_set_style(cont1,LV_CONT_STYLE_MAIN,&cont1_style_main);
		lv_cont_set_fit(cont1,LV_FIT_NONE);
		lv_cont_set_layout(cont1,LV_LAYOUT_OFF);
		cont1_style_main.body.main_color = LV_COLOR_BLACK;
		cont1_style_main.body.grad_color = LV_COLOR_BLACK;
		cont1_style_main.body.border.opa = 60;  //

//-------------------------------------------OK图标--------------------------------------//
		lv_label_set_recolor (obj_label_pic_OK,true);
		lv_label_set_long_mode(obj_label_pic_OK,LV_LABEL_LONG_EXPAND);
		// lv_obj_set_size(obj_label_pic_OK,55,55);
		lv_label_set_style(obj_label_pic_OK,LV_LABEL_STYLE_MAIN,&Label_style_pic_OK);
		lv_obj_set_pos (obj_label_pic_OK, offsetx, offsety);
		Label_style_pic_OK.text.font = &my_font_icon_Filter;
		lv_label_set_text (obj_label_pic_OK,FILTER_RSR);
		Label_style_pic_OK.text.opa = 0;
		Label_style_pic_OK.text.color=LV_COLOR_MAKE(0x5e,0xbd,0x82); //绿色#5EBD82;


//---------------------------------------------大滤网图标----------------------------------------//
		lv_label_set_style(obj_label_pic_filter,LV_LABEL_STYLE_MAIN,&Label_style_pic_filter);
		Label_style_pic_filter.text.font = &my_font_icon_Filter;
		lv_label_set_text (obj_label_pic_filter,FILTER_RSR1);
		Label_style_pic_filter.text.color = LV_COLOR_WHITE;
		Label_style_pic_filter.text.opa = 0;
		lv_obj_set_pos (obj_label_pic_filter, offsetx, offsety);

//---------------------------------------------Flter reset字符----------------------------------------//
		lv_obj_set_size(obj_label_text_filterstatus,200,40);
		lv_label_set_long_mode (obj_label_text_filterreset, LV_LABEL_LONG_EXPAND);
		lv_obj_align(obj_label_text_filterreset,cont1,LV_ALIGN_IN_TOP_LEFT,32,15);
		lv_label_set_align(obj_label_text_filterreset,LV_ALIGN_IN_TOP_MID);
		lv_label_set_style(obj_label_text_filterreset,LV_LABEL_STYLE_MAIN,&Label_style_text_filterreset);
		lv_obj_set_auto_realign (obj_label_text_filterreset, true);
		Label_style_text_filterreset.text.font = &my_font_icon_L;
		lv_label_set_text (obj_label_text_filterreset,"Filter reset");
		Label_style_text_filterreset.text.letter_space = 0;
		Label_style_text_filterreset.text.opa = 0;


//---------------------------------------------Filter status 字符----------------------------------------//
		lv_label_set_long_mode (obj_label_text_filterstatus, LV_LABEL_LONG_EXPAND);
		lv_obj_set_size(obj_label_text_filterstatus,200,40);
		lv_obj_align(obj_label_text_filterstatus,cont1,LV_ALIGN_IN_TOP_LEFT,25,15);
		lv_label_set_align(obj_label_text_filterstatus,LV_ALIGN_IN_TOP_MID);
		lv_obj_set_auto_realign (obj_label_text_filterstatus, true);
		lv_label_set_style(obj_label_text_filterstatus,LV_LABEL_STYLE_MAIN,&Label_style_text_filterstatus);
		Label_style_text_filterstatus.text.font = &my_font_icon_L;
		lv_label_set_text (obj_label_text_filterstatus,"Filter status");
		Label_style_text_filterstatus.text.letter_space = 0;
		Label_style_text_filterstatus.text.opa = 0;


//---------------------------------------------100% 字符----------------------------------------//
		lv_label_set_recolor (obj_label_text_100percent,true);
		lv_label_set_long_mode (obj_label_text_100percent, LV_LABEL_LONG_EXPAND);
		lv_obj_set_pos(obj_label_text_100percent,131,100); // 131 100
		lv_obj_set_size(obj_label_text_100percent,180,50);
		// lv_obj_align(obj_label_text_100percent,cont2,LV_ALIGN_CENTER,60,25);
		// lv_obj_set_auto_realign(obj_label_text_100percent,true);
		lv_label_set_style(obj_label_text_100percent,LV_LABEL_STYLE_MAIN,&cont1_style_main);
		cont1_style_main.text.font = &my_font_icon_L;
		// lv_label_set_text (obj_label_text_100percent,"#5EBD82 100%%#");
		lv_label_set_array_text (obj_label_text_100percent, &table_100percentdispgreen[0],15);
		cont1_style_main.text.letter_space = 0;
		cont1_style_main.text.opa = 0;



//---------------------------------------------滤网图标内部Indicate指示----------------------------------------//
		lv_obj_set_size(bar1,14,60);
		lv_bar_set_range(bar1,0,100);
		lv_bar_set_value(bar1,Sys.Filter.percentage,LV_ANIM_OFF);
		lv_bar_set_style(bar1,LV_BAR_STYLE_BG,&bar1_style_bg);
		lv_bar_set_style(bar1,LV_BAR_STYLE_INDIC,&bar1_style_indic);

		bar1_style_bg.body.main_color = LV_COLOR_BLACK;
		bar1_style_bg.body.grad_color = LV_COLOR_BLACK;
		if(Sys.Filter.percentage>50)
		{
			bar1_style_indic.body.main_color = LV_COLOR_MAKE(0x5e,0xbd,0x82); //绿色#5EBD82
			bar1_style_indic.body.grad_color = LV_COLOR_MAKE(0x5e,0xbd,0x82); //绿色#5EBD82
		}
		else if(Sys.Filter.percentage>20)
		{
			bar1_style_indic.body.main_color = LV_COLOR_MAKE(0xff,0xCF,0x00); //黄色#FFCF00
			bar1_style_indic.body.grad_color = LV_COLOR_MAKE(0xff,0xCF,0x00); //黄色#FFCF00
		}
		else
		{
			bar1_style_indic.body.main_color = LV_COLOR_MAKE(0xff,0x21,0x24);  //红色#FF2124
			bar1_style_indic.body.grad_color = LV_COLOR_MAKE(0xff,0x21,0x24);  //红色#FF2124
		}
		bar1_style_indic.body.radius = 0;
		bar1_style_indic.body.padding.inner =0;
		bar1_style_indic.body.padding.left = 0;
		bar1_style_indic.body.padding.top = 0;
		bar1_style_indic.body.padding.right = 0;
		bar1_style_indic.body.padding.bottom = 0;
		bar1_style_indic.body.border.part = LV_BORDER_FULL;
		lv_obj_align(bar1,obj_label_pic_filter,LV_ALIGN_CENTER,0,0); // -1 10
		bar1_style_bg.body.opa = 0;
		bar1_style_indic.body.opa = 0;


	}
//

	if(Lvgl.Filtercnt%20 == 0 && Lvgl.Filtercnt<400) // 20帧
	{
		lv_obj_refresh_style (scr);
	}
	else if(Lvgl.Filtercnt%20 == 0 && Lvgl.Filtercnt<=600)
	{
		cont1_style_main.body.border.opa+=10;
		lv_obj_refresh_style (scr);
	}
	else if(Lvgl.Filtercnt%20 == 0 && Lvgl.Filtercnt<=2200)
	{
		if(Label_style_text_filterreset.text.opa<255)
			Label_style_text_filterreset.text.opa += 3;
		if(Lvgl.Filtercnt>=1000)
		{
			if(Label_style_pic_OK.text.opa<255)
				Label_style_pic_OK.text.opa += 4;
		}
		if(Lvgl.Filtercnt==2200)
		{
			Label_style_pic_OK.text.opa = 255;
			Label_style_text_filterreset.text.opa = 255;
		}
		lv_obj_refresh_style (scr);
	}
	else if(Lvgl.Filtercnt%20 == 0 && Lvgl.Filtercnt<=2600) // 0.4S 20帧
	{
		Label_style_pic_OK.text.opa -=12;
		Label_style_pic_filter.text.opa+=12;
		bar1_style_bg.body.opa += 12;
		bar1_style_indic.body.opa += 12;
		if(Lvgl.Filtercnt==2600)
		{
			Label_style_pic_OK.text.opa =0;
			Label_style_pic_filter.text.opa =255;
			bar1_style_bg.body.opa = 255;
			bar1_style_indic.body.opa = 255;
//			lv_obj_del (obj_label_pic_OK);
		}
		lv_obj_refresh_style (scr);
	}
	else if(Lvgl.Filtercnt%20 == 0 && Lvgl.Filtercnt<=3400) // 0.8S 40帧
	{

		Label_style_text_filterreset.text.opa -=6;
		Label_style_text_filterstatus.text.opa+=6;
//		x=lv_obj_get_x (obj_label_pic_filter);
//		y=lv_obj_get_y (obj_label_pic_filter);
//		x1=lv_obj_get_x (obj_label_pic_OK);
//		y1=lv_obj_get_y (obj_label_pic_OK);
		if(Lvgl.Filtercnt<=3200)
		{
			offsetx-=1;
			lv_obj_set_pos (obj_label_pic_filter, offsetx, offsety);
		}
		cont1_style_main.text.opa +=6;

		if(Lvgl.Filtercnt == 3400)
		{
			Label_style_text_filterreset.text.opa = 0;
			Label_style_text_filterstatus.text.opa = 255;
			cont1_style_main.text.opa = 255;

		}
		lv_obj_refresh_style (scr);
	}
	else if(Lvgl.Filtercnt>3400&&Lvgl.Filtercnt<=4400) // 1S 50帧
	{
//		if(Lvgl.Taskcomplete&&Lvgl.Taskonce==1)
//		{
//			Lvgl.Taskonce = 2;
//			lv_obj_del (obj_label_text_filterreset);
//		}
		;
	}
	else if(Lvgl.Filtercnt%40 == 0 && Lvgl.Filtercnt<=5200) // 0.8S 20帧
	{
//		lv_obj_refresh_style (scr);

		Label_style_text_filterstatus.text.opa -=12;
		cont1_style_main.text.opa-=12;
		bar1_style_bg.body.opa -=12;
		bar1_style_indic.body.opa-=12;
		Label_style_pic_filter.text.opa-=12;
		cont1_style_main.body.opa -=12;
		cont1_style_main.body.border.opa-=8;
		lv_obj_refresh_style (scr);

	}
	else if(Lvgl.Filtercnt%20 == 0 && Lvgl.Filtercnt<=5300) // 0.8S 20帧
	{

		lv_obj_refresh_style (scr);
	}

	if(++Lvgl.Filtercnt>5200 )
	{
		Lvgl.Filtercnt=0;
		Lvgl.Curpfunction = Lvgl.Lastpfunction;
		lv_obj_refresh_style (scr);
	}

}
void fFactory_process(void)  //产测模式
{
	static lv_obj_t* Src_fac=NULL;  // 工厂模式时候的界面
	static lv_obj_t* label_MainboardSoftwareversion;  // 显示板软件版本
	static lv_obj_t* label_Sensorsoftwareversion;  // 传感器板子软件版本
	static lv_obj_t* label_PCBversion;  // PCB硬件版本
	static lv_obj_t* label_Comletedata;  // 完成日期
	static lv_style_t lv_style_src_fac; 


	if(Src_fac==NULL)	
	{

		//-----------------------------------设置产测专用对象Src_fac---------------------//
		Src_fac=lv_obj_create(scr,NULL);  //设置一个工厂模式的专用对象，父对象为屏幕
		lv_obj_set_size(Src_fac,320,240);	 //设置大小为整个屏幕
		lv_style_copy(&lv_style_src_fac,&lv_style_plain_color); // 将系统颜色参数复制给产测专用的style
		lv_style_src_fac.text.font=&my_font_icon_L; //设置字体为自己生成的小字体
		lv_obj_set_style(Src_fac,&lv_style_src_fac); // 设置style.


		label_MainboardSoftwareversion=lv_label_create(Src_fac,NULL);
		lv_label_set_recolor(label_MainboardSoftwareversion,true); //使能重定义颜色
		lv_label_set_style(label_MainboardSoftwareversion,LV_LABEL_STYLE_MAIN,&lv_style_src_fac);
		lv_obj_set_size(label_MainboardSoftwareversion,100,100);
		lv_obj_set_pos(label_MainboardSoftwareversion,10,10);
		lv_label_set_long_mode(label_MainboardSoftwareversion,LV_LABEL_LONG_EXPAND); // 字符自己扩展
	
		label_Sensorsoftwareversion=lv_label_create(Src_fac,label_MainboardSoftwareversion);
		label_PCBversion=lv_label_create(Src_fac,label_MainboardSoftwareversion);
		label_Comletedata=lv_label_create(Src_fac,label_MainboardSoftwareversion);
		lv_obj_set_pos(label_Sensorsoftwareversion,10,50);
		lv_obj_set_pos(label_PCBversion,10,90);
		lv_obj_set_pos(label_Comletedata,10,130);
		
		lv_label_set_static_text(label_MainboardSoftwareversion,MainBoardVer);
		lv_label_set_text(label_Sensorsoftwareversion,CompleteData);
		lv_label_set_static_text(label_PCBversion,"PCBVer");
		lv_label_set_static_text(label_Comletedata,CompleteData);
	}
	
	

	switch (Sys.Factorysteps)
	{
	case 0:
		/* code */
		lv_style_src_fac.body.main_color = LV_COLOR_RED;
		lv_style_src_fac.body.grad_color = LV_COLOR_RED;
		break;
	case 1:
		/* code */
		lv_style_src_fac.body.main_color = LV_COLOR_GREEN;
		lv_style_src_fac.body.grad_color = LV_COLOR_GREEN;
		break;
	case 2:
		/* code */
		lv_style_src_fac.body.main_color = LV_COLOR_BLUE;
		lv_style_src_fac.body.grad_color = LV_COLOR_BLUE;
		break;
	case 3:
		/* code */
		LED_Key_auto_on();
		break;
	case 4:
		/* code */
		LED_Key_sleep_on();
		break;
	case 5:
		/* code */
		LED_Key_speed_on();
		break;
	case 6:
		/* code */
		LED_Key_filter_on();
		break;
	case 7:
		/* code */
		LED_Key_power_on();
		break;
	case 8:
		/* code */
		LED_Key_timer_on();
		break;
	
	default:
		break;
	}
	
	
	
	
	
	Sys.Factoryflg = 1; // 产测模式

}


void sleep_screen(void)
{

	static u8 inverse = 0;
	if(Sys.power)
	{
		if((Sys.opmode==emodeSleep)&&(Sys.Sleep3S_Cnt>0)&& (KeyStatus&KEY_Release)) //需要按键放开才能进行
		{
			Sys.Sleep3S_Cnt--;
		}

		Main_screen_clean ();
		if(obj_img_sleep ==NULL)
		{
			obj_img_sleep = lv_img_create (scr,NULL);
			lv_img_set_src (obj_img_sleep, &sleep5);
			lv_img_set_style (obj_img_sleep, LV_IMG_STYLE_MAIN, &img_style_sleep);
			img_style_sleep.image.color = LV_COLOR_WHITE;
			img_style_sleep.image.intense = 255;
			lv_obj_set_pos(obj_img_sleep, 110, 75);
			lv_obj_refresh_style (scr);// (&img_style_sleep);
		}
		img_style_sleep.image.opa = 255;

		if(Sys.Timer.settingflg||Sys.Timer.setflg) // 有定时设置 或者正在设置
		{
			Task_Timercreate();
			if(Sys.Timer.settingflg && gFre1hzflashflg)
			{
				if(KeyStatus&KEY_LongOnce&&KeyValue==KEY_TIMER) // once标志做为长按不放的标志 借用
					src1_style_Mainscreen_Timer.text.opa = 255;
				else
					src1_style_Mainscreen_Timer.text.opa = 0;
			}
			else
				src1_style_Mainscreen_Timer.text.opa = 255;

			if(Sys.Timer.hour<10)
			{
				table_timer[3] = Sys.Timer.hour+0x30;
				table_timer[4] = 'h';
				lv_label_set_array_text(label_timer,(const char*)&table_timer,5);
			}
			else
			{
				table_timer[3] = Sys.Timer.hour/10+0x30;
				table_timer[4] = Sys.Timer.hour%10+0x30;
				table_timer[5] = 'h';
				lv_label_set_array_text(label_timer,(const char*)&table_timer,6);
			}

		}
		if(Sys.childlock)
		{
			Task_Childlockcreate();
			if(Sys.childlockcnt)
			{
				if(Lvgl.cnt%10 == 0) //
					Sys.childlockcnt--;
				if((Sys.childlockcnt%100)>50)
					src1_style_Mainscreen_Lock.text.opa = 255;
				else
					src1_style_Mainscreen_Lock.text.opa = 0;
			}
			else
			{
				src1_style_Mainscreen_Lock.text.opa = 255;
			}
		}

		if(Lvgl.cnt%10 == 0 && Lvgl.cnt<=3200) // 320 显示博世图标
		{
			if(inverse)
			{
				if(img_style_sleep.image.intense<255)
					img_style_sleep.image.intense += 1;
			}
			else
			{
				if(img_style_sleep.image.intense>0)
					img_style_sleep.image.intense -= 1;
			}
			lv_obj_refresh_style (scr);// (&img_style_sleep);
		}
	}

	Lvgl.cnt++;
	if(Lvgl.cnt >= 3200)
	{
		Lvgl.cnt = 0;
		inverse^=1;
	}


}

void Normal_Display(void)  //正常显示
{

	if(lv_obj_get_hidden(obj_img_bosch)==false && obj_img_bosch!=NULL)
	{
		lv_obj_set_hidden (obj_img_bosch,true); //隐藏博士
	}
	if(Lvgl.cnt == 0)
	{
		Lvgl.cnt = 1;
		img_style_sleep.image.opa = 0;
		Task_Line_Imagecreate ();
		Task_Sensordatacreate();
		Task_Modecreate(); //模式标签的创建 注意这个必须最先创建
		Task_Fancreate(); //风速图标的创建
		Task_Humicreate();
		Task_Temperaturecreate();
		if(lv_obj_get_hidden(label_auto_manual)==true && label_auto_manual!=NULL)
		{
			lv_obj_set_hidden (label_auto_manual,false); //之前如果隐藏了模式标签的话需要显示
		}
//		lv_obj_refresh_style (scr);
	}
	lv_obj_refresh_style (scr);
	if(Lvgl.cnt%10 == 0) //
	{
		Main_screen_display();
		Task_Moderefresh(Sys.opmode);

		Task_Fanrefresh (Sys.Speed.gearreal);
		if(Sys.comm.confirmcnt==0)
		{
			Task_Temprefresh (Sys.Tempvalue);
			Task_Humirefresh(Sys.Humivalue);
		}
		else
		{

			lv_label_set_text(label_humi,"\xEE\x98\x87-\xEE\x98\x84");
			lv_label_set_text(label_temperature,"\xEE\x98\x88-\xEE\x98\x82");
		}
		if(Sys.Warnup_Cnt<=300)  // 30S预热时间内显示
		{
			lv_label_set_array_text(label_tvocvalue,"- - -",5);
			lv_label_set_array_text(label_pm25value,"- - -",5);
		}
		else
		{
			Task_Tvocvalurefresh (Sys.tvocvalue);
			Task_Pm25valuerefresh(Sys.pm25value);
		}

		if(Sys.Timer.setflg ||Sys.Timer.settingflg) // 有定时设置 或者正在设置
		{
			Task_Timercreate();
			if(Sys.Timer.settingflg && gFre1hzflashflg)
				if(KeyStatus&KEY_LongOnce&&KeyValue==KEY_TIMER) // once标志做为长按不放的标志 借用
					src1_style_Mainscreen_Timer.text.opa = 255;
				else
					src1_style_Mainscreen_Timer.text.opa = 0;
			else
				src1_style_Mainscreen_Timer.text.opa = 255;

			if(Sys.Timer.hour<10)
			{
				table_timer[3] = Sys.Timer.hour+0x30;
				table_timer[4] = 'h';
				lv_label_set_array_text(label_timer,(const char*)&table_timer,5);
			}
			else
			{
				table_timer[3] = Sys.Timer.hour/10+0x30;
				table_timer[4] = Sys.Timer.hour%10+0x30;
				table_timer[5] = 'h';
				lv_label_set_array_text(label_timer,(const char*)&table_timer,6);
			}

		}
		else
		{
			src1_style_Mainscreen_Timer.text.opa = 0;
		}

		if(Sys.childlock)
		{
			Task_Childlockcreate();
			if(Sys.childlockcnt)
			{
				Sys.childlockcnt--;
				if((Sys.childlockcnt%100)>50)
					src1_style_Mainscreen_Lock.text.opa = 255;
				else
					src1_style_Mainscreen_Lock.text.opa = 0;
			}
			else
			{
				src1_style_Mainscreen_Lock.text.opa = 255;
			}
		}
		else
		{
			src1_style_Mainscreen_Lock.text.opa = 0;
		}

		if(Sys.Wifitimeoutcnt)
		{
			Task_Wificreate();
			src1_style_Mainscreen_Wifi.text.opa = 255;
		}
		else
		{
			src1_style_Mainscreen_Wifi.text.opa = 0;
		}

	}

	if(++Lvgl.cnt>10)
		Lvgl.cnt = 1;
}

void Turn_On_Animation(void)
{
	if(Sys.power)
	{
		if(Lvgl.cnt == 0)
		{
			if(obj_img_bosch == NULL)
				obj_img_bosch = lv_img_create (scr, NULL);
			if(lv_obj_get_hidden(obj_img_bosch)==true && obj_img_bosch!=NULL)
			{
				lv_obj_set_hidden (obj_img_bosch,false); //显示博士
			}

			if(lv_obj_get_hidden(Img_fanstate)==false && Img_fanstate!=NULL)
			{
				lv_obj_set_hidden (Img_fanstate,true); //隐藏 风速度
			}
			lv_img_set_style(obj_img_bosch, LV_IMG_STYLE_MAIN, &src1_style_Mainscreen);
			lv_img_set_src (obj_img_bosch, &bosch);
			lv_obj_set_pos (obj_img_bosch,80,93);
			src1_style_Mainscreen.image.opa=0;
		}
		else if(Lvgl.cnt == 3000)
		{
			Task_Line_Imagecreate (); 	//画线和彩图
		}
		else if(Lvgl.cnt == 3400)  // 开始绘制中央的PM25 和 TVOC  55 和30的字
		{
			Task_Sensordatacreate();
		}
		else if(Lvgl.cnt == 3800)
		{
			Task_Modecreate(); //模式标签的创建 注意这个必须最先创建
			Task_Fancreate(); //风速图标的创建
			Task_Humicreate();
			Task_Temperaturecreate();
			if(Sys.Timer.setflg)
				Task_Timercreate(); 	//定时标签
			if(Sys.childlock)
				Task_Childlockcreate(); // 锁键的创建
			if(Sys.WifiCommtimeoutcnt)
				Task_Wificreate(); //wifi的创建

		}
		if(Lvgl.cnt%20 == 0 && Lvgl.cnt<=3000) // 50帧 显示博世图标 然后消失
		{

			if(Lvgl.cnt<=1000)
			{
				if(src1_style_Mainscreen.image.opa<250)
					src1_style_Mainscreen.image.opa+=5;
				else
					src1_style_Mainscreen.image.opa=255;
				lv_obj_refresh_style (scr);
			}
			else if(Lvgl.cnt>=2000 && Lvgl.cnt<3000)
			{
				src1_style_Mainscreen.image.opa-=5;
				lv_obj_refresh_style (scr);
			}
		}
		else if(Lvgl.cnt%20 == 0 && Lvgl.cnt<=3400) // 0.4S 20zhen 显示线和彩图
		{

			src1_style_Mainscreen_Bigstyle.line.opa+=5;
			src1_style_Mainscreen_Bigstyle.image.opa += 10;
			lv_obj_refresh_style (scr);
			//		lv_obj_report_style_mod (&src1_style_Mainscreen_Bigstyle);

		}
		else if(Lvgl.cnt%20 == 0 && Lvgl.cnt<=5000) // 1.6 80帧
		{
			src1_style_Mainscreen_Bigstyle.text.opa += 3;  // 表示中间的传感器数值
			src1_style_Mainscreen_Littlestyle.text.opa += 3; //55字体的显示
			if(Lvgl.cnt>=3800)
			{
				if(Sys.opmode == emodeSleep)
				{
					if(lv_obj_get_hidden(label_auto_manual)==false && label_auto_manual!=NULL)
					{
						lv_obj_set_hidden (label_auto_manual,true); //隐藏 标签
					}

					// if(lv_obj_get_hidden(Img_fanstate)==false && Img_fanstate!=NULL)
					// {
					// 	lv_obj_set_hidden (Img_fanstate,true); //隐藏 风速度
					// }
				}
				else
				{
					if(lv_obj_get_hidden(label_auto_manual)==true && label_auto_manual!=NULL)
					{
						lv_obj_set_hidden (label_auto_manual,false); //显示 标签
					}

					// if(Sys.opmode == emodeAuto)
					// {
					// 	if(lv_obj_get_hidden(Img_fanstate)==false && Img_fanstate!=NULL)
					// 	{
					// 		lv_obj_set_hidden (Img_fanstate,true); //隐藏 风速度
					// 	}
					// }
					// else // 手动
					// {
					// 	if(lv_obj_get_hidden(Img_fanstate)==true && Img_fanstate!=NULL)
					// 	{
					// 		lv_obj_set_hidden (Img_fanstate,false); //显示 风速度
					// 	}
					// }
					Task_Moderefresh(Sys.opmode);
				}


				src1_style_Mainscreen.text.opa +=4;  // 屏幕上常规的图片显示
				src1_style_Mainscreen.image.opa +=4;	//风扇图标的显示
			}

			lv_obj_refresh_style (scr);
			//		lv_obj_report_style_mod (&src1_style_Mainscreen);
		}
		if(Lvgl.cnt>3000)
		{
			if(lv_obj_get_hidden(obj_img_bosch)==false && obj_img_bosch!=NULL)
			{
				lv_obj_set_hidden (obj_img_bosch,true); //隐藏博士
			}
		}
		if(++Lvgl.cnt>=5000)
		{
			Lvgl.cnt = 0;
			Lvgl.Curpfunction = Lvgl.Lastpfunction;
		}
	}
	else
	{
		lv_obj_refresh_style (scr);
	}

}




void fTimer_clr (void) //定时清除
{
	memset(&Sys.Timer,0,sizeof(Sys.Timer));
}

void fTimer_set (void) //定时设定
{
	Sys.Timer.setcnt=0;
	if(Sys.Timer.settingflg)
	{
		if(Sys.Timer.hour<12)
			Sys.Timer.hour++;
		else
			Sys.Timer.hour = 0;;
	}
	else
	{
		Sys.Timer.settingflg = 1; //正在设定
		Sys.Timer.hour = 0;;
	}
}

void fTimer_excution(void)
{
	if(Sys.Timer.settingflg&&Sys.Timer.setcnt<TIMERCONFIRMCNT)
	{
		Sys.Timer.setcnt++;
		if(Sys.Timer.setcnt>=TIMERCONFIRMCNT)
		{
			Sys.Timer.settingflg = 0;
			Sys.Timer.setcnt = 0;
			if(Sys.Timer.hour!=0)
				Sys.Timer.setflg = 1; //定时设定完成
			else
				Sys.Timer.setflg = 0;
		}
	}

	if(Sys.Timer.setflg)
	{
		if(++Sys.Timer.excutecnt>=36000)
		{
			Sys.Timer.excutecnt = 0;
			if(Sys.Timer.hour>1)
				Sys.Timer.hour--;
			else
				fTimer_clr ();
		}
	}

}




#define LCD_TOTAL_BUF_SIZE    (240*320)
#define LCD_Buf_Size 768
static uint8_t lcd_buf[LCD_Buf_Size]= {0x00};
void LCD_Clear(uint16_t color)
{
//    u32 i, j;
//    uint8_t data[2] = {0};  //color是16bit的，每个像素点需要两个字节的显存

//    data[0] = color >> 8;
//    data[1] = color;

//    for(i = 0; i < LCD_TOTAL_BUF_SIZE; i++)
//    {
//		LCD_WR_DATA(data[0]);
//		LCD_WR_DATA(data[1]);
//    }
	LCD_WR_REG(0x2a);
	LCD_WR_DATA(0);
	LCD_WR_DATA(0);

	LCD_WR_REG(0x2b);
	LCD_WR_DATA(0);
	LCD_WR_DATA(0);   //设置光标位置
	LCD_WR_REG(0x2c);	  //开始写入GRAM
	memset(&lcd_buf[0],0x00,LCD_Buf_Size);
	u8 i = 0;
	for(i = 0; i<200; i++)
	{

		g_transfer_complete = 0;
		R_DMAC_Reset (&g_transfer_ctrl,&lcd_buf[0]+1, &g_spi0_ctrl.p_regs->SPDR_BY,LCD_Buf_Size-1);
		TFT_CS = 0;
		TFT_WR = 1;
		g_spi0_ctrl.p_regs->SPDR_BY = 0x00;
		while(g_transfer_complete == 0);
		TFT_CS = 1;
	}

	for(i = 0; i<200; i++)
	{

		g_transfer_complete = 0;
		R_DMAC_Reset (&g_transfer_ctrl,&lcd_buf[0]+1, &g_spi0_ctrl.p_regs->SPDR_BY,LCD_Buf_Size-1);
		TFT_CS = 0;
		TFT_WR = 1;
		g_spi0_ctrl.p_regs->SPDR_BY = 0x00;
		while(g_transfer_complete == 0);
		TFT_CS = 1;
	}



}

void LCD_WR_REG(u8 regval)
{

	TFT_CS = 0;
	TFT_WR = 0;
	g_spi0_ctrl.p_regs->SPDR_BY = regval;
	while(g_spi0_ctrl.p_regs->SPSR_b.SPTEF==0 || g_spi0_ctrl.p_regs->SPSR_b.CENDF==0);
	g_spi0_ctrl.p_regs->SPSR_b.CENDF = 0;
	TFT_CS =1;
}
//写LCD数据
//data:要写入的值
void LCD_WR_DATA(u8 data)
{

	TFT_CS = 0;
	TFT_WR = 1;
	g_spi0_ctrl.p_regs->SPDR_BY = data;
	while(g_spi0_ctrl.p_regs->SPSR_b.SPTEF==0 || g_spi0_ctrl.p_regs->SPSR_b.CENDF==0);
	g_spi0_ctrl.p_regs->SPSR_b.CENDF = 0;
	TFT_CS =1;


}

void LCD_Init(void)
{
	TFT_RES=1;
	delay_cnt(200);
	TFT_RES=0;
	delay_cnt(800);
	TFT_RES=1;
	delay_cnt(800);
	TFT_CS = 0;
	//*** ST7789V2-HSD2.0 IPS- ***//
	LCD_WR_REG(0x11);
	delay_cnt(120); //Delay 120ms

	LCD_WR_REG(0x36);  // 屏幕的显示方向等设置
	LCD_WR_DATA(0x60);// 旋转180的话 用0xA0

	LCD_WR_REG(0x3a);    // 像素设置
	LCD_WR_DATA(0x55);	// 16位 565 RGB格式

	LCD_WR_REG(0x21);	// 黑白反色 ,IPS模式

	LCD_WR_REG(0xb2);
	LCD_WR_DATA(0x0c);
	LCD_WR_DATA(0x0c);
	LCD_WR_DATA(0x00);
	LCD_WR_DATA(0x33);
	LCD_WR_DATA(0x33);

	LCD_WR_REG(0xB7);
	LCD_WR_DATA(0x35);   	//35

	LCD_WR_REG(0xBB);     //VOCM
	LCD_WR_DATA(0x12);

	LCD_WR_REG(0xC0);
	LCD_WR_DATA(0x2C);

	LCD_WR_REG(0xC2);
	LCD_WR_DATA(0x01);

	LCD_WR_REG(0xC3);     //GVDD
	LCD_WR_DATA(0x27);

	LCD_WR_REG(0xC4);
	LCD_WR_DATA(0x20);

	LCD_WR_REG(0xC6);
	LCD_WR_DATA(0x0F);

	LCD_WR_REG(0xD0);
	LCD_WR_DATA(0xA4);
	LCD_WR_DATA(0xA1);

	LCD_WR_REG(0xE0);
	LCD_WR_DATA(0xD0);
	LCD_WR_DATA(0x0F);
	LCD_WR_DATA(0x19);
	LCD_WR_DATA(0x0F);
	LCD_WR_DATA(0x10);
	LCD_WR_DATA(0x1B);
	LCD_WR_DATA(0x43);
	LCD_WR_DATA(0x44);
	LCD_WR_DATA(0x51);
	LCD_WR_DATA(0x0A);
	LCD_WR_DATA(0x13);
	LCD_WR_DATA(0x11);
	LCD_WR_DATA(0x20);
	LCD_WR_DATA(0x24);

	LCD_WR_REG(0xE1);
	LCD_WR_DATA(0xD0);
	LCD_WR_DATA(0x0F);
	LCD_WR_DATA(0x18);
	LCD_WR_DATA(0x10);
	LCD_WR_DATA(0x11);
	LCD_WR_DATA(0x1A);
	LCD_WR_DATA(0x42);
	LCD_WR_DATA(0x44);
	LCD_WR_DATA(0x52);
	LCD_WR_DATA(0x0B);
	LCD_WR_DATA(0x17);
	LCD_WR_DATA(0x19);
	LCD_WR_DATA(0x21);
	LCD_WR_DATA(0x24);

//	 LCD_WR_REG(0x55);		// 色彩增强

	LCD_WR_REG(0x29); //Display on

	LCD_WR_REG(0x2b);
	LCD_WR_DATA(0x00);
	LCD_WR_DATA(0x00);
	LCD_WR_DATA(0);
	LCD_WR_DATA(0xEf);

	LCD_WR_REG(0x2a);
	LCD_WR_DATA(0x00);
	LCD_WR_DATA(0x00);
	LCD_WR_DATA(0x01);
	LCD_WR_DATA(0x3f);
	LCD_WR_REG(0x2C); //

	LCD_Clear(0x0000); // 565格式



}

void fBuz_Driver(void)  //蜂鸣器驱动 1MS一次
{
	static u8 cnt = 200;

	// if(Sys.Buzcnt)
	// {
	// 	Sys.Buzcnt--;
	// 	R_GPT_Start (&g_Buzz_pwm_ctrl);
	// 	Buz_En();
	// }
	// else
	// {
	// 	Buz_Dis();
	// 	R_GPT_Stop (&g_Buzz_pwm_ctrl);

	// }
}

void fTurn_on(void)
{
//	Sys.power =1;
	Sys.flowcnt = Flowon;
}

void fTurn_off(void)
{
	Sys.power =0;
	if(Lvgl.Curpfunction!=Turn_On_Animation)
	{
		Lvgl.Curpfunction=Turn_On_Animation;
	}
	Lvgl.cnt = 0;
	Sys.flowcnt = Flowoff;
	Main_screen_clean();
	img_style_sleep.image.opa = 0;
	if(Sys.Warnup_Cnt<=300)
		Sys.Warnup_Cnt=301; // 手动关机直接预热结束
	fTimer_clr();
}

void fLogic_ctrl(void)  //常用的一些逻辑判断  10MS loop
{
	if(Sys.power)
	{
		TFT_LED = 1;
		if(Sys.Sleep3S_Cnt == 0 && (Sys.opmode==emodeSleep))
		{
			TFT_LED = 0;
		}
	}
	else
		TFT_LED = 0;
}
void fKey_GetValue(void)  //获取键值并处理
{
	static u8 status = 0;	//状态变量：0检测是否有键按下，1滤波延时，2等待放开并判断是否长按，3长按等待放开
	static u16 temp1,temp2;
	static u16 counter = 0;
	static u8 counter1 = 0;
	static u8 Counter_Unlike = 0;  //键值不相等滤波
	qe_getvalue();
	if(g_qe_touch_flag==0)
	{
		keyTemp = button_status;
		switch (status)
		{
		case 0:										//扫描按键 检测是否有按下
			temp1 = keyTemp;
			if(!temp1)				//没有键按下
			{
				KeyStatus |= KEY_Release;			//按键放开
				KeyStatus &= ~KEY_LongPress;		//长按标志清零
				KeyStatus &= ~KEY_LongOnce; // 2019.07.24 将长按一次的标志位和长按标志位同时清除
				KeyStatus &= ~KEY_LongPresskeep;  //长按保持标志置位清除
				break;
			}
			status = 1;				//有键按下
			break;
		case 1:																			//有键按下后进行计时
			temp2 = keyTemp;
			if(temp1 == temp2)									//判断是否是相同按键还在按下
			{
				KeyStatus &= ~KEY_Release;		//按键未放开
				counter++;
				if (counter >= KEY_FILTER_COUNT)	//消抖完成
				{
					counter = 0;
					status = 2;											//切换到等待放开状态
					KeyStatus&=~KEY_Release; //按键未放开
					//               KeyValue = temp2;
					//                KeyStatus |= KEY_Available;	//键值有效
					//                KeyStatus |= KEY_ShortPress;  //按下直接响应

				}
			}
			else																//不是同一按键或没有键按下
			{
				KeyStatus |= KEY_Release;			//按键放开
				status = 0;												//判定为抖动，键值判断完成
				counter = 0;
			}
			break;
		case 2:																		//等待放开并判断是否长按
			if(temp2 == keyTemp)							//按键没有放开
			{
				Counter_Unlike = 0;
				counter1=0;
				counter++;											//等待按键放开的计时
				KeyStatus &= ~KEY_Release;		//按键未放开
				if (counter >= KEY_LONG_COUNT)	//达到长按时间长度
				{
					counter = 0;
					KeyValue = temp2;							//长按按键值
					KeyStatus |= KEY_Available;	//键值有效
					KeyStatus |= KEY_LongPress;	//长按标志置位
					KeyStatus |= KEY_LongOnce;  //长按一次标志置位
					KeyStatus |= KEY_LongPresskeep;  //长按保持标志置位
					status = 3;										//切换到长按等待放开状态
				}
			}
			else															//按键已经放开
			{
				counter = 0;
				if(keyTemp !=0)  //按键值不相等
				{
					KeyStatus &= ~KEY_Release;		//按键未放开
					counter1= 0;
					Counter_Unlike++;
					if(Counter_Unlike>=KEY_PULSE_FILTER_COUNT)
					{
						Counter_Unlike = 0;
						status = 0;
					}
				}
				else
				{
					Counter_Unlike = 0;
					counter1++;
					if(counter1>=KEY_PULSE_FILTER_COUNT)
					{
						counter1=0;
						KeyValue = temp2;
						KeyStatus |= KEY_Available;		//键值有效
						KeyStatus &= ~KEY_LongPress;		//长按标志清零
						KeyStatus &= ~KEY_LongOnce; // 2019.07.24 将长按一次的标志位和长按标志位同时清除
						KeyStatus &= ~KEY_LongPresskeep;  //长按保持标志置位清除
						KeyStatus |= KEY_ShortPress;  // 2021.06.29 放开才会响应
						KeyStatus |= KEY_Release;			//按键放开
						status = 0;
					}
				}//键值判断完成
			}
			break;
		case 3:																		//长按等待放开状态
			if(temp2 == keyTemp)										//按键没有放开
			{
				counter1=0;
				Counter_Unlike = 0;
				counter++;											//长按保持的计时
				KeyStatus &= ~KEY_Release;		//按键未放开
				if (counter >= KEY_KEEP_COUNT)	//长按保持计时完成
				{

					counter = 0;
					KeyStatus |= KEY_Available;		//键值有效
					KeyStatus |= KEY_LongPress;		//长按标志
				}
			}
			else															//按键已经放开
			{
				counter = 0;
				if(keyTemp !=0)
				{
					counter1= 0;
					Counter_Unlike++;
					KeyStatus &= ~KEY_Release;		//按键未放开
					if(Counter_Unlike >= KEY_PULSE_FILTER_COUNT)
					{
						Counter_Unlike = 0;
						status = 0;
					}
				}
				else
				{
					Counter_Unlike = 0;
					counter1++;
					if(counter1>=KEY_PULSE_FILTER_COUNT)
					{
						counter1=0;
						KeyStatus &= ~KEY_Available;		//键值无效
						KeyStatus &= ~KEY_LongPress;		//长按标志清零
						KeyStatus &= ~KEY_LongOnce; // 2019.07.24 将长按一次的标志位和长按标志位同时清除
						KeyStatus &= ~KEY_LongPresskeep;  //长按保持标志置位清除
						KeyStatus |= KEY_Release;			//按键放开
						status = 0;
					}
				}//键值判断完成
			}
			break;
		default:
			status = 0;
			break;
		}
	}

}



void fKey_Process(void) //T =6ms
{
	u16 dat = 0;
	fKey_GetValue();

	if(Sys.Timer.settingflg && KeyValue==KEY_TIMER && (KeyStatus&KEY_Release)==0) //定时时候防止进入不了连续调整
	{
		Sys.Timer.setcnt=0;
	}


	if(KeyStatus & KEY_Available)    //键值有效
	{
		KeyStatus &= ~KEY_Available; //键值失效

		dat = KeyValue;
		if(Sys.power)
		{
			if(Sys.opmode==emodeSleep)
			{
				if(Sys.Sleep3S_Cnt==0)
				{
					Sys.Sleep3S_Cnt = SLEEP3S_CNT;
					if(KeyStatus & KEY_ShortPress)
						KeyStatus&=~KEY_ShortPress;
					return;
				}
				else
					Sys.Sleep3S_Cnt = SLEEP3S_CNT;
			}
		}
		else
		{
			if(dat!=KEY_POWER)
			{
				if(KeyStatus & KEY_ShortPress)
					KeyStatus&=~KEY_ShortPress;
				return;
			}
		}

		if(Sys.childlock&&dat!=KEY_POWER) //锁键不能操作
		{
			if(Sys.childlockcnt==0)
				Sys.childlockcnt=300;
			return;
		}

		switch(dat)
		{
		case KEY_POWER:  //开关按键
			if(KeyStatus & KEY_ShortPress) //短按只会执行一次
			{
				KeyStatus&=~KEY_ShortPress;
				if(Sys.childlock)
				{
					if(Sys.childlockcnt==0)
						Sys.childlockcnt=300;
					break;
				}
				if(Sys.power == 0)
					fTurn_on();
				else
					fTurn_off();
				Buz_Beep ();
			}

			if(KeyStatus&KEY_LongOnce)
			{
				KeyStatus &=~KEY_LongOnce;
				Sys.childlock^=1;
				Buz_Beep ();
			}
			break;
		case KEY_SLEEP:	//模式按键
			if(KeyStatus & KEY_ShortPress)
			{
				KeyStatus&=~KEY_ShortPress;
				if(Lvgl.Curpfunction != sleep_screen)
				{
					Lvgl.cnt = 0;
					Lvgl.Lastpfunction=Lvgl.Curpfunction = sleep_screen;
				}
				Sys.Sleep3S_Cnt = SLEEP3S_CNT;
				Sys.opmode = emodeSleep;
				Buz_Beep ();
			}

			if(KeyStatus&KEY_LongOnce)
			{
				KeyStatus &=~KEY_LongOnce;
				if(Sys.opmode!=emodeSleep)
				{
					Sys.AQI_DISABLE^=1;
				}

			}
			break;
		case KEY_AUTO:  // 自动模式
			if(KeyStatus & KEY_ShortPress)
			{
				KeyStatus&=~KEY_ShortPress;
				if(Lvgl.Curpfunction != Normal_Display)
				{
					Lvgl.cnt = 0;
					Lvgl.Lastpfunction=Lvgl.Curpfunction = Normal_Display;
				}
				if(Sys.opmode!=emodeAuto)
					Sys.opmode = emodeAuto;
			}
			Buz_Beep ();
			if(KeyStatus&KEY_LongOnce)
			{
				KeyStatus &=~KEY_LongOnce;

			}
			break;
		case KEY_FILTER:  // 灯光按键 滤网按键
			if(KeyStatus & KEY_ShortPress)
			{
				KeyStatus&=~KEY_ShortPress;
				if((Lvgl.Curpfunction != Filter_display) && (Lvgl.Curpfunction != Filter_reset_animation))
				{
					Lvgl.Lastpfunction = Lvgl.Curpfunction;
					Lvgl.Filtercnt = 0;
					Lvgl.Curpfunction = Filter_display;
				}
				Buz_Beep ();
			}

			if(KeyStatus&KEY_LongOnce)
			{
				KeyStatus &=~KEY_LongOnce;

				if((Lvgl.Curpfunction != Filter_reset_animation) &&(Lvgl.Curpfunction != Filter_display))
				{
					Lvgl.Lastpfunction = Lvgl.Curpfunction;
					Lvgl.Filtercnt = 0;
					Lvgl.Curpfunction = Filter_reset_animation;
				}
				Buz_Beep ();
			}
			break;
		case KEY_TIMER:  // 定时按键
			if(KeyStatus & KEY_ShortPress)
			{
				KeyStatus&=~KEY_ShortPress;
				if(Sys.power)
				{
					if(Sys.Timer.setflg)
					{
						fTimer_clr();  // 清除定时
					}
					else
					{
						fTimer_set (); //设置定时
					}
//					if(Lvgl.Curpfunction != Normal_Display)
//					{
//						Lvgl.cnt = 0;
//						Lvgl.Lastpfunction=Lvgl.Curpfunction = Normal_Display;
//					}
					Buz_Beep ();
				}

			}
			if(KeyStatus&KEY_LongPress)
			{
				KeyStatus &=~KEY_LongPress;

				if(Sys.Timer.settingflg)
				{
					Sys.Timer.setcnt=0;
					if(Sys.Timer.hour<12)
						Sys.Timer.hour++;
					else
						Sys.Timer.hour = 0;
				}
			}
			break;
		case KEY_SPEED:  // 风速调整
			if(KeyStatus & KEY_ShortPress)
			{
				KeyStatus&=~KEY_ShortPress;

				if(Sys.power)
				{
					if(Lvgl.Curpfunction != Normal_Display)
					{
						Lvgl.cnt = 0;
						Lvgl.Lastpfunction=Lvgl.Curpfunction = Normal_Display;
					}
					if(Sys.opmode!=emodeManual)
					{
						Sys.opmode = emodeManual;
					}
					else
					{
						Sys.Speed.gear++;
						if(Sys.Speed.gear>espd5)
							Sys.Speed.gear = espd1;
					}
					Buz_Beep ();
				}

			}
			if(KeyStatus&KEY_LongOnce)
			{
				KeyStatus &=~KEY_LongOnce;

			}
			break;
		default	:
			break;
		}
	}


}

void SpeedInit(void)
{
	Sys.Speed.Delta = 0;
	Sys.Speed.Delta2 = 0;
	Sys.Speed.DeltaLast = 0;
	Sys.Speed.FeedBack = 0;
	Sys.Speed.P = 0;
	Sys.Speed.I = 0;
	Sys.Speed.Target = 0;//
	Sys.Speed.PrePutOut = 3500;//可以提高启动速度
	Sys.Speed.PutOut = 0;//高电平反而是无效电平
	Sys.Speed.Reference = 0;
}
void fFanFeedBackCalc(void)
{
	FG.Cnt++;
	if(FG.Cnt > 4800)//小于100rpm
	{
		FG.Cnt = 0; //清零，重新计数
		FG.CalCnt = 0;  //按0转
		FG.CycleCnt = 0;
		Sys.Speed.FeedBack = 0;
		return;
	}

//		if(Motor_FB_IO)//读取反馈端口的电平
//		{//高电平
//			FG.Cnt_H++;
//			if(FG.Cnt_H>=4)
//			{
//				FG.Cnt_H = 4;
//				FG.Cnt_L = 0;
//			}
//			if(FG.State)
//			{
//				FG.State = 0;//防止重复计数
//
//			}
//		}
//		else
//		{
//			FG.Cnt_L++;
//			if(FG.Cnt_L>=4)
//			{
//				FG.Cnt_L = 4;
//				FG.Cnt_H = 0;
//				if(FG.State == 0)
//				{
//					if(FG.CycleCnt==0)  //从新开始计算
//					{
//						FG.Cnt = 0;
//					}
//					FG.State = 1;
//					FG.CycleCnt++;
//					if(FG.CycleCnt>=2)
//					{
//						FG.CycleCnt = 1;
//						FG.CalCnt = FG.Cnt*12;
//						FG.Cnt = 0;
//					}
//				}
//			}
//
//		}
	if(Pin_CheckMotor)//读取反馈端口的电平
	{
		//高电平
		if(FG.State)
		{
			FG.State = 0;//防止重复计数
			FG.CycleCnt++;
		}
	}
	else
	{
		if(FG.State == 0)
		{
			FG.State = 1;
			FG.CycleCnt++;
		}
	}
	if(FG.CycleCnt >= 24)//直流风机有12个周期反馈，高低电平变化24次
	{
		FG.CycleCnt = 0;
		if(FG.Cnt < 160)//大于3000rpm
			FG.Cnt = 160;
		FG.CalCnt = FG.Cnt;
		FG.Cnt = 0;
		Sys.Speed.FeedBack = 480000/FG.CalCnt;
	}


}

void fFilter_Cal(void) //滤网寿命计算
{
	if(Sys.power&&(Sys.Errcode&(bit0|bit7)==0))
	{
		if(++Sys.Filter.calcnt>=3600)
		{
			Sys.Filter.calcnt=0;
			if(Sys.Filter.accumulatedhour<Sys.Filter.maxhour)
				Sys.Filter.accumulatedhour++;
		}

	}
	Sys.Filter.percentage = 100-(Sys.Filter.accumulatedhour*100/Sys.Filter.maxhour);
}

void fBoard_Sensordatahandle(void)
{
	u8 i = 0;
	volatile u16 tvoctmp;
	volatile u16 PM25tmp;
	i = Sys.comm.rxdata[2];
	if(Sys.comm.rxdata[0]==0x5f && Sys.comm.rxdata[1]==0x50 && Sys.comm.rxdata[i-1]==Sys.comm.rxdatasum)
	{
		if(Sys.comm.rxdata[4]&bit5)
			Sys.Errcode |=bit5;
		else
			Sys.Errcode &=~bit5;

		if(Sys.comm.rxdata[4]&bit2)
			Sys.Errcode |=bit2;
		else
			Sys.Errcode &=~bit2;

		if(Sys.comm.rxdata[4]&bit3)
			Sys.Errcode |=bit3;
		else
			Sys.Errcode &=~bit3;

		if(Sys.comm.rxdata[4]&bit0)
			Sys.Errcode |=bit7;
		else
			Sys.Errcode &=~bit7;

		Sys.softwareversion = Sys.comm.rxdata[5];
		Sys.pm25softwareversion = Sys.comm.rxdata[6];
		Sys.tvocversion = Sys.comm.rxdata[7];
		Sys.pcbversion = Sys.comm.rxdata[8];
		PM25tmp = (Sys.comm.rxdata[9]<<8)|Sys.comm.rxdata[10];
		Sys.Tempvalue = ((s8)(Sys.comm.rxdata[11]-20));
		Sys.Humivalue = Sys.comm.rxdata[12];
		Sys.tvocvalue =1;
		tvoctmp= (Sys.comm.rxdata[13])|Sys.comm.rxdata[14]<<8;
		if(PM25tmp==0)
			PM25tmp=1;
		Sys.pm25value = PM25tmp;
		if(tvoctmp==3)
			Sys.tvocvalue = 2;
		else if(tvoctmp==7)
			Sys.tvocvalue = 3;
		else if(tvoctmp==11)
			Sys.tvocvalue = 4;
		else
			Sys.tvocvalue =1;
		if(Sys.comm.confirmcnt)
			Sys.comm.confirmcnt--;
		Sys.comm.steps = 2;
	}
	else
	{
		Sys.comm.steps = 2; //不发送
	}
	memset(Sys.comm.rxdata,0,sizeof(Sys.comm.rxdata));
	Sys.comm.rxdatasum = 0;
	Sys.comm.rxindex = 0;

}
void fBoard_Sensorcommflow(void) // 2ms
{
	u8 i,j= 0;

	switch(Sys.comm.steps)
	{
	case 0:
		i = 0;
		Sys.comm.txdata[i++]= 0x5f;
		Sys.comm.txdata[i++]= 0x50;
		Sys.comm.txdata[i++]= 0x06;
		Sys.comm.txdata[i++]= 0x00;
		Sys.comm.txdata[i++]= (Sys.power<<1);
		Sys.comm.txdata[i] = 0;
		for(j=0; j<i; j++)
		{
			Sys.comm.txdata[i]+=Sys.comm.txdata[j];
		}
		i++;
		R_SCI_UART_Write (&g_uart_sensor_ctrl,&Sys.comm.txdata[0],6);
		Sys.comm.rxindex = 0;
		Sys.comm.steps = 1;
		break;
	case 1:
		if(++Sys.comm.rxcnt>=150)
		{
			Sys.comm.rxcnt = 0;
			fBoard_Sensordatahandle();
		}
		break;
	case 2:
		; // wait
		break;
	}
//	switch(Sys.comm.steps)
//	{
//		case 0:
//			if(++Sys.comm.rxcnt>=20)
//			{
//				Sys.comm.rxcnt = 0;
//
//				fBoard_Sensordatahandle();
//			}
//			break;
//		case 1:
//			i = 0;
//			Sys.comm.txdata[i++]= 0x5f;
//			Sys.comm.txdata[i++]= 0x50;
//			Sys.comm.txdata[i++]= 0x06;
//			Sys.comm.txdata[i++]= 0x00;
//			Sys.comm.txdata[i++]= (Sys.power<<1);
//			Sys.comm.txdata[i] = 0;
//			for(j=0;j<i;j++)
//			{
//				Sys.comm.txdata[i]+=Sys.comm.txdata[j];
//			}
//			i++;
//			R_SCI_UART_Write (&g_uart_sensor_ctrl,&Sys.comm.txdata[0],6);
//			Sys.comm.rxindex = 0;
//			Sys.comm.steps = 2;
//			break;
//
//		case 2:
//			; // wait
//			break;
//	}

	if(++Sys.comm.flowcnt>=500)
	{
		Sys.comm.flowcnt=0;
		Sys.comm.steps = 0;
	}
}
void fMotor_ctrl(void)
{
	static signed long s32_ChangeValue = 0;
	static unsigned long u32_ChangeValue = 0;
	volatile u32 tmp = 0;
	volatile u32 Point = 0;
	u32 *p = 0;
	p = &Motorpara.Spd_Off;
	static u16 sErr_30s=0;
	if(Sys.Errcode&(bit0|bit7))  //风机故障 或者 锁机的情况下
	{
		PWR_MOTOR_DIS();
		Motorpara.Spd_Output[0] = Motorpara.Spd_Off[0];
	}
	else
	{
		if(Sys.power)  //开机状态下
		{
			if(++Sys.delaycnt>=10)
			{
				Sys.delaycnt = 10;
				PWR_MOTOR_EN();
			}
			if(Sys.Speed.FeedBack<100)  //连续5S风速反馈小于100  报风机故障
			{
				sErr_30s++;
				if(sErr_30s>=300)
				{
					sErr_30s = 300;
					Sys.Errcode |=0x01;  // 5S之内没达到100转
				}
			}
			else   // 风速正常 计数清除
				sErr_30s = 0;

			switch (Sys.opmode)
			{
			case emodeAuto:
				if(Sys.Warnup_Cnt<=300)  //预热30S之内风速保持最低挡位
				{
					Motorpara.Spd_Output[0] = tAuto_Spd[0];
					Sys.Speed.gearreal = 0;
				}
				else
				{
					Sys.Speed.gearreal = Sys.AQI_LEVEL;
					switch (Sys.AQI_LEVEL)
					{
					case 0:
						Motorpara.Spd_Output[0] = tAuto_Spd[0];

						break;
					case 1:
						Motorpara.Spd_Output[0] = tAuto_Spd[1];
						break;
					case 2:
						Motorpara.Spd_Output[0] = tAuto_Spd[2];
						break;
					case 3:
						Motorpara.Spd_Output[0] = tAuto_Spd[3];
						break;
					default:
						Motorpara.Spd_Output[0] = tAuto_Spd[0];
						Sys.Speed.gearreal = 0;
						break;
					}
				}
				break;
			case emodeManual:
				Sys.Speed.gearreal = Sys.Speed.gear;
				switch(Sys.Speed.gear)
				{
				case espd1:
					Motorpara.Spd_Output[0] = Motorpara.Spd1[0];
					break;
				case espd2:
					Motorpara.Spd_Output[0] = Motorpara.Spd2[0];
					break;
				case espd3:
					Motorpara.Spd_Output[0] = Motorpara.Spd3[0];
					break;
				case espd4:
					Motorpara.Spd_Output[0] = Motorpara.Spd4[0];
					break;
				case espd5:
					Motorpara.Spd_Output[0] = Motorpara.Spd5[0];
					break;
				default:
					Motorpara.Spd_Output[0] = Motorpara.Spd_Off[0];
					Sys.Speed.gearreal = 0;
					break;
				}

				break;
			case emodeSleep:
				Motorpara.Spd_Output[0] = Motorpara.Spd1[0];
				Sys.Speed.gearreal = 0;
				break;
			default:
				Motorpara.Spd_Output[0] = Motorpara.Spd_Off[0];
				Sys.Speed.gearreal = 0;
				break;

			}
		}
		else
		{
			PWR_MOTOR_DIS();
			Motorpara.Spd_Output[0] = Motorpara.Spd_Off[0];
			sErr_30s = 0;

		}
	}

	if((Sys.Errcode&(bit0|bit7))==0 && Sys.power) //开机并且没有错误的情况下
	{
		Sys.Speed.Target = Motorpara.Spd_Output[0];
		//这里还应该需要添加失速计数，但是规格书里没看到失速保护
		if(abs(Sys.Speed.Target- Sys.Speed.FeedBack)>=500)
		{
			if(Sys.Speed.Reference < Sys.Speed.Target)
				Sys.Speed.Reference += 10;
			else if(Sys.Speed.Reference > Sys.Speed.Target)
				Sys.Speed.Reference -= 10;
		}
		else if(abs(Sys.Speed.Target- Sys.Speed.FeedBack)>=100)
		{
			if(Sys.Speed.Reference < Sys.Speed.Target)
				Sys.Speed.Reference += 3;
			else if(Sys.Speed.Reference > Sys.Speed.Target)
				Sys.Speed.Reference -= 3;
		}
		else
		{
			if(Sys.Speed.Reference < Sys.Speed.Target)
				Sys.Speed.Reference += 1;
			else if(Sys.Speed.Reference > Sys.Speed.Target)
				Sys.Speed.Reference -= 1;
		}

		Sys.Speed.Delta = (s16)(Sys.Speed.Reference - Sys.Speed.FeedBack);
		Sys.Speed.Delta2 = Sys.Speed.Delta - Sys.Speed.DeltaLast;
		Sys.Speed.P = Sys.Speed.Delta/PID_Kp;
		Sys.Speed.I = Sys.Speed.Delta2 / PID_Ki;
		Sys.Speed.DeltaLast = Sys.Speed.Delta;
		Sys.Speed.PrePutOut = Sys.Speed.PrePutOut+Sys.Speed.P+Sys.Speed.I;

		if(Sys.Speed.PrePutOut > MaxPutOut)
			Sys.Speed.PrePutOut = MaxPutOut;
		else if(Sys.Speed.PrePutOut < MinPutOut)
			Sys.Speed.PrePutOut = MinPutOut;

		Sys.Speed.PutOut = SPDOFF-Sys.Speed.PrePutOut;
	}
	else
	{

		Sys.Speed.Delta = 0;
		Sys.Speed.Delta2 = 0;
		Sys.Speed.DeltaLast = 0;
//		Sys.Speed.FeedBack = 0;
		Sys.Speed.P = 0;
		Sys.Speed.I = 0;
		Sys.Speed.Target = 0;//
		Sys.Speed.PrePutOut = 6000;//可以提高启动速度
		Sys.Speed.PutOut = SPDOFF;
		Sys.Speed.Reference = Sys.Speed.FeedBack;

	}
	R_GPT_DutyCycleSet(&g_motor_pwm_ctrl,Sys.Speed.PutOut,GPT_IO_PIN_GTIOCA);

}
void fDisp_LedDriver(void) // LED驱动控制 125us
{
	static uint8_t Duty_Cnt =0;
	static u8 s_Dim1_Cnt=0;
	volatile u16 gAQIduty_Bluetmp = 0;
	volatile u16 gAQIduty_Redtmp = 0;
	volatile u16 gAQIduty_Greentmp = 0;

	static u16 gAQIduty_Blue;
	static u16 gAQIduty_Red;
	static u16 gAQIduty_Green;


	static u16 sBreath_dutyset=0;
	static u8 sBreath_dutycnt=0;
	volatile u16 sBreath_dutytmp = 0;
	if(Sys.power||Sys.flowcnt<=Flowon)
	{
		if(Sys.opmode == emodeSleep)
		{
			if(Sys.Sleep3S_Cnt == 0) //关闭灯光
			{
				LED_key_all_off();
			}
			else   // 降低亮度
			{
				sBreath_dutytmp = 10;
				if(sBreath_dutycnt<sBreath_dutytmp)
				{
					LED_key_all_on();
				}
				else
				{
					LED_key_all_off();
				}
			}
		}
		else
		{
			if(sBreath_dutycnt<25)
			{
				LED_key_all_on();
			}
			else
			{
				LED_key_all_off();
			}
		}
	}
	else
	{
		LED_key_withoutpower_off();
		if(sBreath_dutyset>=4000)
		{
			sBreath_dutytmp = 0;
		}
		else
		{
			sBreath_dutytmp = (sBreath_dutyset>=2000)?(3999-sBreath_dutyset):(sBreath_dutyset);
			sBreath_dutytmp=sBreath_dutytmp/40;
		}

		if(sBreath_dutycnt<sBreath_dutytmp)
		{
			LED_Key_power_on ();
		}
		else
		{
			LED_Key_power_off ();
		}

	}
	if(++sBreath_dutycnt>=50)  // 一个周期完成 DIM需要在完整周期时候调整 不然怕混色不均匀
	{
		sBreath_dutycnt = 0;
		sBreath_dutyset+=10;
		if(sBreath_dutyset>=4050)
			sBreath_dutyset = 0;

	}

//------------------------AQI驱动--------------------------

	switch(Sys.AQI_LEVEL)
	{
	case 0:

		gAQIduty_Red  = 0;
		gAQIduty_Green   =0;
		gAQIduty_Blue = 100;
		break;
	case 1:
		gAQIduty_Red  = 50;
		gAQIduty_Green   =12;
		gAQIduty_Blue = 96;

		break;
	case 2:

		gAQIduty_Red  = 80;
		gAQIduty_Green   =100;
		gAQIduty_Blue = 0;

		break;
	case 3:
		gAQIduty_Red  = 100;
		gAQIduty_Green   =0;
		gAQIduty_Blue = 0;

		break;
	case 4:
		gAQIduty_Red  = 0;
		gAQIduty_Green   =0;
		gAQIduty_Blue = 0;

		break;
//	 case 5:
//		gAQIduty_Blue = 0;
//		gAQIduty_Red  = 100;
//		gAQIduty_Green   =0;
//        break;
//	 case 6:
//		gAQIduty_Blue = 0;
//		gAQIduty_Red  = 0;
//		gAQIduty_Green   =100;
//        break;
//	 case 7:
//		gAQIduty_Blue = 100;
//		gAQIduty_Red  = 0;
//		gAQIduty_Green   =0;
//        break;
//
//		case 8:
//			   gAQIduty_Blue = 100;
//			   gAQIduty_Red  = 100;
//			   gAQIduty_Green	=100;
//			   break;

//	case 9:
//			   gAQIduty_Blue = BB;
//			   gAQIduty_Red  = R;
//			   gAQIduty_Green	=G;
//			   break;



	default:
		gAQIduty_Red  = 0;
		gAQIduty_Green   =0;
		gAQIduty_Blue = 0;
		break;

	}

	gAQIduty_Bluetmp = gAQIduty_Blue;
	gAQIduty_Redtmp = gAQIduty_Red;
	gAQIduty_Greentmp = gAQIduty_Green;

//	gAQIduty_Bluetmp = gAQIduty_Bluetmp*85;
//	gAQIduty_Bluetmp = gAQIduty_Bluetmp/100;
//	gAQIduty_Redtmp = gAQIduty_Redtmp*85;
//	gAQIduty_Redtmp = gAQIduty_Redtmp/100;  // 亮度全部降低为原先的85%
	if(Sys.power == 0 || Sys.AQI_DISABLE ||Sys.opmode==emodeSleep||Sys.flowcnt>0)  //工厂产测模 或者AQI关 或者睡眠模式下LED全部关闭
	{
		LED_RGB_ALLOFF();
		return;
	}
	else
	{

		if(Duty_Cnt<=gAQIduty_Redtmp&&gAQIduty_Redtmp>0) //占空比计数时间大于0 并且小于等于所占比例数的时候，开启相应的灯光
		{
			LED_RGB_RED_ON ();

		}
		else  //非占空比时间内全部关闭
		{
			LED_RGB_RED_OFF ();
		}
		if(Duty_Cnt<=gAQIduty_Bluetmp&&gAQIduty_Bluetmp>0) //同上面红色 下面的蓝色做出不同混合颜色
		{
			LED_RGB_BLUE_ON ();

		}
		else //同上
		{
			LED_RGB_BLUE_OFF ();
		}

		if(Duty_Cnt<=gAQIduty_Greentmp&&gAQIduty_Greentmp>0) //同上面 做出不同混合颜色
		{

			LED_RGB_GREEN_ON ();
		}
		else //同上
		{
			LED_RGB_GREEN_OFF ();
		}
		if(++Duty_Cnt>100)  // 一个周期完成 DIM需要在完整周期时候调整 不然怕混色不均匀
		{
			Duty_Cnt = 0;
		}



	}

}

void fDisp_Init(void)
{
	scr = lv_scr_act(); //父对象 屏幕
	lv_style_copy(&label_style_auto_manual,&lv_style_plain_color);
	lv_style_copy(&src1_style_3rd,&lv_style_plain_color);
	lv_style_copy(&src1_style_Mainscreen,&lv_style_plain_color);
	lv_style_copy(&src1_style_2nd,&lv_style_plain_color);
	lv_style_copy(&Img_style_ColorLine,&lv_style_plain_color);
	lv_style_copy(&img_style_sleep,&lv_style_plain_color);
	lv_style_copy(&src1_style_Mainscreen_Bigstyle,&lv_style_plain_color);
	lv_style_copy(&src1_style_Mainscreen_Littlestyle,&lv_style_plain_color);
	lv_style_copy(&src1_style_Mainscreen_Timer,&lv_style_plain_color);
	lv_style_copy(&src1_style_Mainscreen_Wifi,&lv_style_plain_color);
	lv_style_copy(&src1_style_Mainscreen_Lock,&lv_style_plain_color);
	src1_style_Mainscreen.text.font = &my_font_icon_L;  // 字体为自建字体
	src1_style_Mainscreen_Timer.text.font= &my_font_icon_L;
	src1_style_Mainscreen_Wifi.text.font= &my_font_icon_L;
	src1_style_Mainscreen_Lock.text.font= &my_font_icon_L;
	src1_style_Mainscreen_Bigstyle.text.font= &my_font_icon_B;
	src1_style_Mainscreen_Littlestyle.text.font= &my_font_icon_L;


	src1_style_3rd.text.font = &my_font_icon_L;  // 字体为自建字体
	src1_style_2nd.text.font = &my_font_icon_B;


	Lvgl.Initcomplete = 1; // 初始化完毕 可以执行任务了

}
void  Sys_Init(void) //系统初始化函数
{
	TFT_CS = 1;
	TFT_RES = 1;
	TFT_LED = 0;

	R_GPT_Open (&g_timer0_125us_ctrl,&g_timer0_125us_cfg); // 1MS中断 给LVGL 提供心跳


	R_GPT_Open (&g_timer1_ctrl,&g_timer1_cfg); // 1ms
	R_DMAC_Open(&g_transfer_ctrl, &g_transfer_cfg);
	/* Enable the DMAC so that it responds to transfer requests. */
	R_DMAC_Enable(&g_transfer_ctrl);
	R_SPI_Open (&g_spi0_ctrl, &g_spi0_cfg);

//	R_FLASH_HP_Open (&g_flash0_ctrl,&g_flash0_cfg);
	R_FLASH_HP_Open(&g_flash0_ctrl, &g_flash0_cfg);


	R_GPT_Open (&g_motor_pwm_ctrl,&g_motor_pwm_cfg); // 电机驱动pwm
	R_GPT_DutyCycleSet(&g_motor_pwm_ctrl,SPDOFF,GPT_IO_PIN_GTIOCA);
	R_GPT_Start (&g_motor_pwm_ctrl);
	R_GPT_DutyCycleSet(&g_motor_pwm_ctrl,SPDOFF,GPT_IO_PIN_GTIOCA);


	// R_GPT_Open (&g_Buzz_pwm_ctrl,&g_Buzz_pwm_cfg); // 电机驱动pwm
	// R_GPT_DutyCycleSet(&g_Buzz_pwm_ctrl,0x30d4,GPT_IO_PIN_GTIOCB);


//	R_GPT_Start (&g_Buzz_pwm_ctrl);

	R_SCI_UART_Open(&g_uart_sensor_ctrl,&g_uart_sensor_cfg); // 1MS中断 给LVGL 提供心跳

//	__IOM uint32_t IELS : 9;   /*!< [8..0] ICU Event selection to NVICSet the number for the event
//										   *   signal to be linked .													 */
//			   uint32_t 		   : 7;
//			   __IOM uint32_t IR   : 1;   /*!< [16..16] Interrupt Status Flag											 */
//			   uint32_t 		   : 7;
//			   __IOM uint32_t DTCE : 1;   /*!< [24..24] DTC Activation Enable											 */
//			   uint32_t 		   : 7;

	/* Open the transfer instance with initial configuration. */
//	g_spi0_ctrl.p_regs->SPCR3_b.BFDS = 1;

	R_ICU->IELSR[5] = 0;  // 设置不需要IE中断  DMA 中断就可以了

	g_spi0_ctrl.p_regs->SPCR_b.SPEIE = 0; //不要中断
//	g_spi0_ctrl.p_regs->SPCR_b.SPTIE = 0; //不要中断
	g_spi0_ctrl.p_regs->SPCR_b.SPRIE = 0; //不要中断
	g_spi0_ctrl.p_regs->SPCR2_b.SPIIE = 0; //不要中断
//
	g_spi0_ctrl.p_regs->SPCR3_b.CENDIE = 0; //不要中断  发送完成中断

	g_spi0_ctrl.p_regs->SPDCR_b.SPBYT = 1;
	g_spi0_ctrl.p_regs->SPCMD[0] = 0xe780;
	g_spi0_ctrl.p_regs->SPCR_b.SPE = 1; // SPI功能打开



}
void fFlashdata_read(void)
{
	volatile u8 g_src[50]= {0};
	volatile u8 i = 0;
	u32 Addr = FLASH_HP_DF_BLOCK_0;
	u8 checksum = 0;
	u8 datalen = 0;
//---------------------获取配置信息信息-----------------------------
//	Addr = FLASH_HP_DF_BLOCK_0;
//	do
//	{
//		memset(&g_src[0],0,sizeof(g_src)); //缓存数据数组清除
//
//		datalen = *((uint8_t *)(Addr+2));
//		if(datalen> sizeof(g_src))
//			datalen = sizeof(g_src);
//		for(i=0; i<datalen; i++) //获取数据参数
//	    {
//	        g_src[i] = *((uint8_t *)(Addr+i));
//			if(i<(datalen-2))
//				checksum+= g_src[i];
//	    }
//		Addr+=FLASH_HP_DF_BLOCK_SIZE;
//		if(g_src[0]==0x5F &&g_src[1]==0x50&& (checksum== g_src[datalen-2]) && (g_src[datalen-1]==0xfa))
//		{
//			i = 3;
//			Sys.Filter.accumulatedhour = g_src[i++];
//			Sys.Filter.accumulatedhour<<=8;
//			Sys.Filter.accumulatedhour |= g_src[i++];
//
//			Sys.power = g_src[i++];
//			if(Sys.power==1)
//			{
//				Sys.Warnup_Cnt=301; // 掉电记忆是开机直接跳过30秒预热
//				Sys.opmode = g_src[i++];
//
//				Sys.Speed.gear = g_src[i++];
//				if(Sys.opmode == emodeSleep)
//					Lvgl.Lastpfunction=Lvgl.Curpfunction = sleep_screen;
//				else
//					Lvgl.Lastpfunction=Lvgl.Curpfunction = Normal_Display;
//
//			}
//			break;
//		}

//	}
//	while (Addr<=FLASH_HP_DF_BLOCK_1);
	fFilter_Cal();  //滤网寿命计算



}
void fFlashdata_deal(void)
{
	u8 *p = 0;
	volatile u8 i,j= 0;
	volatile u8 checksum = 0;
	static u8 handlewaitcnt =0;
	static u8 handletimeslimit = 0;
	volatile u8 g_src[50]= {0};
	g_src[i++]=0x5f;
	g_src[i++]=0x50;
	i++;
	g_src[i++]=Sys.Filter.accumulatedhour>>8;
	g_src[i++]=Sys.Filter.accumulatedhour&0xff;
	g_src[i++]=Sys.power;
	g_src[i++]=Sys.opmode;

	g_src[i++]=Sys.Speed.gear;

	g_src[i++]=checksum;
	g_src[i++]=0xfa;
	g_src[2]=i;
	for(j=0; j<(i-2); j++)
	{
		checksum +=g_src[j];
	}
	g_src[i-2]=checksum;
	if(memcmp(&g_src[0],(u8 *)FLASH_DF_BLOCK_0,i)!=0 && memcmp(&g_src[0],(u8 *)FLASH_DF_BLOCK_1,i)!=0)
	{
		if(handletimeslimit<=20)
		{
			if(++handlewaitcnt>=50)
			{
				handlewaitcnt = 0;

				r_flash_hp_bgo_2855(0,&g_src[0],i);
				if(memcmp(&g_src[0],(u8 *)FLASH_DF_BLOCK_0,i)!=0 && memcmp(&g_src[0],(u8 *)FLASH_DF_BLOCK_1,i)!=0)
					handletimeslimit++;
			}
		}
	}
	else
	{

		handletimeslimit = 0;
		handlewaitcnt = 0;
	}
}
void fDeviceData_Init(void)
{
	Sys.opmode = emodeAuto;
	Sys.Speed.gear = 0;
	Sys.Filter.maxhour = 3000;
	Sys.power = 0;
	Sys.Filter.accumulatedhour = 0;
	Lvgl.Curpfunction = Turn_On_Animation;
	
	Lvgl.Lastpfunction = Normal_Display;
	Lvgl.cnt = 0;
	Lvgl.Filtercnt = 0;
	Sys.pm25value = 1;
	Sys.tvocvalue = 1;
	Sys.Filter.calcnt = 0;
	Sys.comm.confirmcnt = 4;
	Sys.Sleep3S_Cnt = SLEEP3S_CNT;
	Sys.flowcnt = Flowoff;
}


void fDustlevel_cal(void)
{
	static u8  cnt = 0;
	if(Sys.Warnup_Cnt<300)
	{
		if(Sys.Warnup_Cnt%8==0 &&Sys.Warnup_Cnt>0)
		{
			if(Sys.AQI_LEVEL<3)
				Sys.AQI_LEVEL++;
			else
				Sys.AQI_LEVEL = 0;
		}
		return;
	}
	if(++cnt>=50)
	{
		cnt = 0;
		if(Sys.pm25value>=tAQI_table[Sys.AQI_LEVEL][1])
		{
			if(Sys.AQI_LEVEL<3)
				Sys.AQI_LEVEL++;
			else
				Sys.AQI_LEVEL = 3;
		}
		else if(Sys.pm25value<=tAQI_table[Sys.AQI_LEVEL][0])
		{
			if(Sys.AQI_LEVEL>1)
				Sys.AQI_LEVEL--;
			else
				Sys.AQI_LEVEL = 0;
		}
	}
}

void fLCD_reinit(void)
{
	LCD_WR_REG(0x36);  // 屏幕的显示方向等设置
	LCD_WR_DATA(0x60);// 旋转180的话 用0xA0

	LCD_WR_REG(0x3a);    // 像素设置
	LCD_WR_DATA(0x55);	// 16位 565 RGB格式

	LCD_WR_REG(0x21);	// 黑白反色 ,IPS模式

	LCD_WR_REG(0xb2);
	LCD_WR_DATA(0x0c);
	LCD_WR_DATA(0x0c);
	LCD_WR_DATA(0x00);
	LCD_WR_DATA(0x33);
	LCD_WR_DATA(0x33);

	LCD_WR_REG(0xB7);
	LCD_WR_DATA(0x35);   	//35

	LCD_WR_REG(0xBB);     //VOCM
	LCD_WR_DATA(0x12);

	LCD_WR_REG(0xC0);
	LCD_WR_DATA(0x2C);

	LCD_WR_REG(0xC2);
	LCD_WR_DATA(0x01);

	LCD_WR_REG(0xC3);     //GVDD
	LCD_WR_DATA(0x27);

	LCD_WR_REG(0xC4);
	LCD_WR_DATA(0x20);

	LCD_WR_REG(0xC6);
	LCD_WR_DATA(0x0F);

	LCD_WR_REG(0xD0);
	LCD_WR_DATA(0xA4);
	LCD_WR_DATA(0xA1);

	LCD_WR_REG(0xE0);
	LCD_WR_DATA(0xD0);
	LCD_WR_DATA(0x0F);
	LCD_WR_DATA(0x19);
	LCD_WR_DATA(0x0F);
	LCD_WR_DATA(0x10);
	LCD_WR_DATA(0x1B);
	LCD_WR_DATA(0x43);
	LCD_WR_DATA(0x44);
	LCD_WR_DATA(0x51);
	LCD_WR_DATA(0x0A);
	LCD_WR_DATA(0x13);
	LCD_WR_DATA(0x11);
	LCD_WR_DATA(0x20);
	LCD_WR_DATA(0x24);

	LCD_WR_REG(0xE1);
	LCD_WR_DATA(0xD0);
	LCD_WR_DATA(0x0F);
	LCD_WR_DATA(0x18);
	LCD_WR_DATA(0x10);
	LCD_WR_DATA(0x11);
	LCD_WR_DATA(0x1A);
	LCD_WR_DATA(0x42);
	LCD_WR_DATA(0x44);
	LCD_WR_DATA(0x52);
	LCD_WR_DATA(0x0B);
	LCD_WR_DATA(0x17);
	LCD_WR_DATA(0x19);
	LCD_WR_DATA(0x21);
	LCD_WR_DATA(0x24);

//	 LCD_WR_REG(0x55);		// 色彩增强

	LCD_WR_REG(0x29); //Display on
}




/*
2022.01.16
1.开始记录开发步骤

2022.01.23
和曾伟对话内容 董工，程序有几点问题：
1.AQI灯显示颜色为绿紫橙红，要改为蓝紫橙红；(对应颜色PM25差值也更改.)  OK
2.睡眠后AQI灯没有灭，睡眠后要灭AQI灯；  OK
3.在任意模式下，长按睡眠键3S要能关闭/开启AQI灯；  OK
4.PM2.5范围不准，上升缓慢，建议改为取30S内数据的平均值； 祝工修改
5.关机后开机要有开机动画；OK
6.断电后再上电，屏幕会显示-20度； OK
7.AUTO模式时，档位不用显示。 OK

2022.02.14
1.风速对应计算公式修改，风机现在是12转一圈.
2.风速对应表更新.

2022.02.16
1.重新对于线条和进度条颜色取色，彩条宽度减半.

2022.02.27
1.由于PCB升级为第三版本，所以部分IO口相对应的有所调整.修改宏定义.修改PWM输出部分原先是GTIOCB改为GTIOCA
2.显示旋转了180°,修改显示参数
3.修改一些字模和字体。
4.增加一函数自检显示使用.(只完成一部分)
5.还有滤网复位时候的透明变化未实现.

2022.02.28
1.继续完善自检部分的图形显示和功能. 未完成
2.继续完善一些之前反馈的问题和已知的bug. 未完成
3.宏定义添加花括号或者括号.
4.小字体里面增加冒号的字体.
5.按键参数调整，后续还需要继续优化.
*/
void hal_entry(void)
{
	/* TODO: add your own code here */
	qe_touch_Init ();
	Sys_Init();
	lv_init(); //lvgl系统初始化
	lv_port_disp_init(); //lvgl显示接口初始化 ,放在 lv_init()的后面
	LCD_Init();
	__disable_irq();
	fDisp_Init();
	Buz_Beep ();
	fDeviceData_Init();
	fFlashdata_read();
	R_GPT_Start (&g_timer1_ctrl);
	R_GPT_Start (&g_timer0_125us_ctrl);
	__enable_irq();
	while(1)
	{
		Lvgl.Taskcomplete = 0;
		lv_task_handler(); // 任务处理器
		Lvgl.Taskcomplete = 1;
		if(Sys.Factoryflg)
		{
			Lvgl.Curpfunction = fFactory_process;
		}
		if(gTime100msflg)
		{
			gTime100msflg = 0;

			fMotor_ctrl();
//			TEST_PINP100 = 1;
			fFlashdata_deal();
//			TEST_PINP100 = 0;
		}

		if(gTime1sflg)
		{
			gTime1sflg = 0;
			fFilter_Cal();  //滤网寿命计算
			
			// fLCD_reinit();
		}
	}
#if BSP_TZ_SECURE_BUILD
	/* Enter non-secure code */
	R_BSP_NonSecureEnter();
#endif
}



void Timer0_125us_callback (timer_callback_args_t * p_args)
{
	fFanFeedBackCalc();
	fDisp_LedDriver();
}
void Timer1_1ms_callback (timer_callback_args_t * p_args)
{
	static u16 sT1mscnt=0;
	sT1mscnt++;
	tim1ms_flg = 1;
	lv_tick_inc(1); //LVGL 1MS的心跳包

	if(Lvgl.Initcomplete==1) //初始化结束
	{
		(*Lvgl.Curpfunction)();
	}

	fKey_Process();  // 按键处理函数  键值获取大概需要5ms 时间

	if(Lvgl.Curpfunction!=Filter_reset_animation)
	{
		if(cont1!=NULL)
		{
			if(lv_obj_get_hidden (cont1)==false)
				lv_obj_set_hidden (cont1, true);
		}
	}

	if(Lvgl.Curpfunction!=Filter_display)
	{
		if(cont2!=NULL)
		{
			if(lv_obj_get_hidden (cont2)==false)
				lv_obj_set_hidden (cont2, true);
		}
	}

	if((sT1mscnt%10)==0)
	{
		fLogic_ctrl ();
	}

	if((sT1mscnt%100)==0)
	{
		gTime100msflg = 0x0f;
		if(Sys.power&&Sys.Warnup_Cnt<=600)
			Sys.Warnup_Cnt++;
		if(Sys.Plugin_Cnt<=600)
			Sys.Plugin_Cnt++;
		fTimer_excution(); //定时执行 100MS
		fDustlevel_cal();
		if(Sys.flowcnt<=Flowon&&Sys.flowcnt>0)
			Sys.flowcnt--;
		if(Sys.flowcnt==Flow_turnonTFT&&Sys.power==0)
			Sys.power = 1;

	}

	if((sT1mscnt%500)==0)
	{
		gFre1hzflashflg^=1;  //1HZ频率  0.5S取反
		gTime500msflg = 1;
	}

	if((sT1mscnt%1000)==0)
	{
		gFre0_5hzflashflg ^=1;
		gTime1sflg = 0xff;
		

	}
	if(sT1mscnt>=8000)
		sT1mscnt = 0;
	fBuz_Driver(); //蜂鸣器
	fBoard_Sensorcommflow();

}

void spi_callback (spi_callback_args_t * p_args)
{
	;
}
void uart_sensor_callback(uart_callback_args_t * p_args)
{
	if(p_args->event==UART_EVENT_RX_CHAR)
	{
		Sys.comm.steps = 1;
		Sys.comm.rxcnt=0;
		if(Sys.comm.rxindex == 0)
		{
			Sys.comm.rxdatasum = 0;
		}
		Sys.comm.rxdata[Sys.comm.rxindex] = p_args->data;
		if(Sys.comm.rxdata[2]==(Sys.comm.rxindex+1) && Sys.comm.rxindex>2)
			;
		else
			Sys.comm.rxdatasum+= Sys.comm.rxdata[Sys.comm.rxindex];
		Sys.comm.rxindex++;

	}

}
void uart1_wifi_callback (uart_callback_args_t * p_args)
{
	;
}


volatile bool g_transfer_complete = false;
void dmac_callback (dmac_callback_args_t * cb_data)
{
//    FSP_PARAMETER_NOT_USED(cb_data);
	static u8 i = 1;
	uint16_t height,width;

	if(Lvgl.Initcomplete == 1)
	{
		TFT_CS = 1;
		width=area_gloable.x2-area_gloable.x1+1; 			//得到填充的宽度
		height=area_gloable.y2-area_gloable.y1+1;			//高度
		if(i<height)
		{
			LCD_WR_REG(0x2a);
			LCD_WR_DATA(0);
			LCD_WR_DATA(area_gloable.x1);
			LCD_WR_REG(0x2b);
			LCD_WR_DATA((area_gloable.y1+i)>>8);
			LCD_WR_DATA((area_gloable.y1+i)&0xff);   //设置光标位置
			LCD_WR_REG(0x2c);     //开始写入GRAM
			R_DMAC_Reset (&g_transfer_ctrl,((u8 *)color_gloable)+1, &g_spi0_ctrl.p_regs->SPDR_BY,width*2-1);
			TFT_CS = 0;
			TFT_WR = 1;
			g_spi0_ctrl.p_regs->SPDR_BY = color_gloable[0]&0xff;
			color_gloable+=width;
			i++;
		}
		else
		{
			lv_disp_flush_ready(disp_drv_gloable);
			i = 1;
		}


	}

	g_transfer_complete = true;

}



static fsp_err_t blankcheck_event_flag(void)
{
	fsp_err_t err = FSP_SUCCESS;
	/* Wait for callback function to set flag */
	while (!(g_b_flash_event_not_blank || g_b_flash_event_blank));

	if (g_b_flash_event_not_blank)
	{
		/* Reset Flag */
		g_b_flash_event_not_blank = false;
		return (fsp_err_t)FLASH_EVENT_NOT_BLANK;
	}
	else
	{
		/* Reset Flag */
		g_b_flash_event_blank = false;
	}
	return err;
}

fsp_err_t r_flash_hp_bgo_2855 ( u8 const blocks,uint32_t const src_address,uint32_t const num_bytes)
{
	u8 *p =0;
	u8 j = 0;
	volatile uint32_t flash_address;
	fsp_err_t err = FSP_SUCCESS;
	flash_result_t blank_check_result = FLASH_RESULT_BLANK;


	flash_address=FLASH_HP_DF_BLOCK_0+blocks*64;
//	 err =R_FLASH_HP_StartUpAreaSelect (&g_flash0_ctrl, FLASH_STARTUP_AREA_BLOCK0, true);
//
//
//	err = R_FLASH_HP_Erase(&g_flash0_ctrl, FLASH_HP_DF_BLOCK_0, 2);

//	  /* Wait for the erase complete event flag, if BGO is SET  */
//    if (true == g_flash0_cfg.data_flash_bgo)
//    {
//        while (!g_b_flash_event_erase_complete);
//        g_b_flash_event_erase_complete = false;
//    }

//	  /* Data flash blank check */
//    err = R_FLASH_HP_BlankCheck(&g_flash0_ctrl, FLASH_HP_DF_BLOCK_0,FLASH_HP_DF_BLOCK_SIZE, &blank_check_result);
//	    /* Validate the blank check result */
//    if (FLASH_RESULT_BLANK == blank_check_result)
//    {
//		;
//    }
//    else if (FLASH_RESULT_NOT_BLANK == blank_check_result)
//    {
//		;
//        return (fsp_err_t)FLASH_RESULT_NOT_BLANK;
//    }
//    else if (FLASH_RESULT_BGO_ACTIVE == blank_check_result)
//    {
//        /* BlankCheck will update in Callback */
//        /* Event flag will be updated in the blank check function when BGO is enabled */
//        err = blankcheck_event_flag();
//        if(FSP_SUCCESS != err)
//        {
//            return err;
//        }
//    }
//    else
//    {
//        /* No Operation */
//    }
//	j=0;
//	p=(u8 *)0x08000000;
//	while(j<64)
//	{
//		g_src[j++]= *p++;
//
//	}

//	p=(u8 *)0x08000040;
//	while(j<128)
//	{
//		g_src[j++]= *p++;
//
//	}
	err = R_FLASH_HP_Erase(&g_flash0_ctrl, flash_address, 10);

	/* Wait for the erase complete event flag, if BGO is SET	*/
	if (true == g_flash0_cfg.data_flash_bgo)
	{
		while (!g_b_flash_event_erase_complete);
		g_b_flash_event_erase_complete = false;
	}
//	err=R_FLASH_HP_BlankCheck (&g_flash0_ctrl, flash_address,num_bytes, &blank_check_result);
//	/* Write code flash data*/
//	while (!(g_b_flash_event_not_blank || g_b_flash_event_blank));

//    if (g_b_flash_event_not_blank)
//    {
//		/* Reset Flag */
//        g_b_flash_event_not_blank = false;
//        return (fsp_err_t)FLASH_EVENT_NOT_BLANK;
//    }
//    else
//    {        /* Reset Flag */
//        g_b_flash_event_blank = false;
//    }
	err = R_FLASH_HP_Write(&g_flash0_ctrl, src_address,flash_address, num_bytes);
	/* Error Handle */
	/* Wait for the write complete event flag, if BGO is SET  */
	flash_status_t status;
	/* Wait until the current flash operation completes. */
	do
	{
		err = R_FLASH_HP_StatusGet(&g_flash0_ctrl, &status);
	}
	while ((FSP_SUCCESS == err) && (FLASH_STATUS_BUSY == status));


	err = R_FLASH_HP_Erase(&g_flash0_ctrl, flash_address+64, 1);

	/* Wait for the erase complete event flag, if BGO is SET	*/
	if (true == g_flash0_cfg.data_flash_bgo)
	{
		while (!g_b_flash_event_erase_complete);
		g_b_flash_event_erase_complete = false;
	}
	/* Write code flash data*/
	err = R_FLASH_HP_Write(&g_flash0_ctrl, src_address,flash_address+64, num_bytes);
	/* Error Handle */
	/* Wait for the write complete event flag, if BGO is SET  */
	/* Wait until the current flash operation completes. */
	do
	{
		err = R_FLASH_HP_StatusGet(&g_flash0_ctrl, &status);
	}
	while ((FSP_SUCCESS == err) && (FLASH_STATUS_BUSY == status));



}

void r_flash_hp_bgo_example (void)
{
	/* Initialize p_src to known data */
	/* Open the flash hp instance. */
	fsp_err_t err = R_FLASH_HP_Open(&g_flash0_ctrl, &g_flash0_cfg);
	/* Handle any errors. This function should be defined by the user. */
//    handle_error(err);
	interrupt_called = false;
	/* Erase 1 block of data flash starting at block 0. */
	err = R_FLASH_HP_Erase(&g_flash0_ctrl, FLASH_DF_BLOCK_0, 8);
//    handle_error(err);
	while (!interrupt_called)
	{
		;
	}
//    if (FLASH_EVENT_ERASE_COMPLETE != flash_event)
//    {
//        handle_error(FSP_ERR_ERASE_FAILED);
//    }
	interrupt_called = false;
	/* Write 32 bytes to the first block of data flash. */
	err = R_FLASH_HP_Write(&g_flash0_ctrl, &Sys.flashsrc[0], FLASH_DF_BLOCK_0, 10);
//    handle_error(err);
	flash_status_t status;
	/* Wait until the current flash operation completes. */
	do
	{
		err = R_FLASH_HP_StatusGet(&g_flash0_ctrl, &status);
	}
	while ((FSP_SUCCESS == err) && (FLASH_STATUS_BUSY == status));
//    /* If the interrupt wasn't called process the error. */
//    if (!interrupt_called)
//    {
//        handle_error(FSP_ERR_WRITE_FAILED);
//    }
//    /* If the event wasn't a write complete process the error. */
//    if (FLASH_EVENT_WRITE_COMPLETE != flash_event)
//    {
//        handle_error(FSP_ERR_WRITE_FAILED);
//    }
//    /* Verify the data was written correctly. */
//    if (0 != memcmp(g_src, (uint8_t *) FLASH_DF_BLOCK_0, FLASH_HP_EXAMPLE_WRITE_SIZE))
//    {
//        handle_error(FSP_ERR_WRITE_FAILED);
//    }
}





void g_flash0_callback  (flash_callback_args_t * p_args)
{
	interrupt_called = true;
	flash_event      = p_args->event;

	if (FLASH_EVENT_NOT_BLANK == p_args->event)
	{
		g_b_flash_event_not_blank = true;
	}
	else if (FLASH_EVENT_BLANK == p_args->event)
	{
		g_b_flash_event_blank = true;
	}
	else if (FLASH_EVENT_ERASE_COMPLETE == p_args->event)
	{
		g_b_flash_event_erase_complete = true;
	}
	else if (FLASH_EVENT_WRITE_COMPLETE == p_args->event)
	{
		g_b_flash_event_write_complete = true;
	}
	else
	{
		/*No operation */
	}
}


/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
	if (BSP_WARM_START_RESET == event)
	{
#if BSP_FEATURE_FLASH_LP_VERSION != 0

		/* Enable reading from data flash. */
		R_FACI_LP->DFLCTL = 1U;

		/* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
		 * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
	}

	if (BSP_WARM_START_POST_C == event)
	{
		/* C runtime environment and system clocks are setup. */

		/* Configure pins. */
		R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);
	}
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
